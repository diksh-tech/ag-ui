# server.py
import os
import logging
import json
from typing import Optional, Any, Dict
from datetime import datetime
from motor.motor_asyncio import AsyncIOMotorClient
from dotenv import load_dotenv
load_dotenv() 

from mcp.server.fastmcp import FastMCP

HOST = os.getenv("MCP_HOST", "127.0.0.1")
PORT = int(os.getenv("MCP_PORT", "8000"))
TRANSPORT = os.getenv("MCP_TRANSPORT", "streamable-http")

MONGODB_URL = os.getenv("MONGO_URI")
DATABASE_NAME = os.getenv("MONGO_DB")
COLLECTION_NAME = os.getenv("MONGO_COLLECTION")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("flightops.mcp.server")

mcp = FastMCP("FlightOps MCP Server")

_mongo_client: Optional[AsyncIOMotorClient] = None
_db = None
_col = None

async def get_mongodb_client():
    """Initialize and return the global Motor client, DB and collection."""
    global _mongo_client, _db, _col
    if _mongo_client is None:
        logger.info("Connecting to MongoDB: %s", MONGODB_URL)
        _mongo_client = AsyncIOMotorClient(MONGODB_URL)
        _db = _mongo_client[DATABASE_NAME]
        _col = _db[COLLECTION_NAME]
    return _mongo_client, _db, _col

def normalize_flight_number(flight_number: Any) -> Optional[int]:
    """Convert flight_number to int. MongoDB stores it as int."""
    if flight_number is None or flight_number == "":
        return None
    if isinstance(flight_number, int):
        return flight_number
    try:
        return int(str(flight_number).strip())
    except (ValueError, TypeError):
        logger.warning(f"Could not normalize flight_number: {flight_number}")
        return None

def validate_date(date_str: str) -> Optional[str]:
    """
    Validate date_of_origin string. Accepts common formats.
    Returns normalized ISO date string YYYY-MM-DD if valid, else None.
    """
    if not date_str or date_str == "":
        return None
    
    # Handle common date formats
    formats = [
        "%Y-%m-%d",      # 2024-06-23
        "%d-%m-%Y",      # 23-06-2024
        "%Y/%m/%d",      # 2024/06/23
        "%d/%m/%Y",      # 23/06/2024
        "%B %d, %Y",     # June 23, 2024
        "%d %B %Y",      # 23 June 2024
        "%b %d, %Y",     # Jun 23, 2024
        "%d %b %Y"       # 23 Jun 2024
    ]
    
    for fmt in formats:
        try:
            dt = datetime.strptime(date_str, fmt)
            return dt.strftime("%Y-%m-%d")
        except ValueError:
            continue
    
    logger.warning(f"Could not parse date: {date_str}")
    return None

def make_query(carrier: str, flight_number: Optional[int], date_of_origin: str) -> Dict:
    """
    Build MongoDB query matching the actual database schema.
    """
    query = {}
    
    # Add carrier if provided
    if carrier:
        query["flightLegState.carrier"] = carrier
    
    # Add flight number as integer (as stored in DB)
    if flight_number is not None:
        query["flightLegState.flightNumber"] = flight_number
    
    # Add date if provided
    if date_of_origin:
        query["flightLegState.dateOfOrigin"] = date_of_origin
    
    logger.info(f"Built query: {json.dumps(query)}")
    return query

def response_ok(data: Any) -> str:
    """Return JSON string for successful response."""
    return json.dumps({"ok": True, "data": data}, indent=2, default=str)

def response_error(msg: str, code: int = 400) -> str:
    """Return JSON string for error response."""
    return json.dumps({"ok": False, "error": {"message": msg, "code": code}}, indent=2)

async def _fetch_one_async(query: dict, projection: dict) -> str:          #  Point of concern
    """
    Consistent async DB fetch and error handling.
    Returns JSON string response.
    """
    try:
        _, _, col = await get_mongodb_client()
        logger.info(f"Executing query: {json.dumps(query)}")
        
        result = await col.find_one(query, projection)
        
        if not result:
            logger.warning(f"No document found for query: {json.dumps(query)}")
            return response_error("No matching document found.", code=404)
        
        # Remove _id and _class to keep output clean
        if "_id" in result:
            result.pop("_id")
        if "_class" in result:
            result.pop("_class")
        
        logger.info(f"Query successful")
        return response_ok(result)
    except Exception as exc:
        logger.exception("DB query failed")
        return response_error(f"DB query failed: {str(exc)}", code=500)

# --- MCP Tools ---

@mcp.tool()
async def health_check() -> str:
    """
    Simple health check for orchestrators and clients.
    Attempts a cheap DB ping.
    """
    try:
        _, _, col = await get_mongodb_client()
        doc = await col.find_one({}, {"_id": 1})
        return response_ok({"status": "ok", "db_connected": doc is not None})
    except Exception as e:
        logger.exception("Health check DB ping failed")
        return response_error("DB unreachable", code=503)

@mcp.tool()
async def get_flight_basic_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Fetch basic flight information including carrier, flight number, date, stations, times, and status.
    
    Args:
        carrier: Airline carrier code (e.g., "6E", "AI")
        flight_number: Flight number as string (e.g., "215")
        date_of_origin: Date in YYYY-MM-DD format (e.g., "2024-06-23")
    """
    logger.info(f"get_flight_basic_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    # Normalize inputs
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date_of_origin format. Expected YYYY-MM-DD or common date formats", 400)
    
    query = make_query(carrier, fn, dob)
    
    # Project basic flight information
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.suffix": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.seqNumber": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.startStationICAO": 1,
        "flightLegState.endStationICAO": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.flightStatus": 1,
        "flightLegState.operationalStatus": 1,
        "flightLegState.flightType": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_operation_times(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Return estimated and actual operation times for a flight including takeoff, landing, block times.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_operation_times: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date format.", 400)
    
    query = make_query(carrier, fn, dob)
    
    projection = {
       
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.operation.estimatedTimes": 1,
        "flightLegState.operation.actualTimes": 1,
        "flightLegState.taxiOutTime": 1,
        "flightLegState.taxiInTime": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_equipment_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get aircraft equipment details including aircraft type, registration (tail number), and configuration.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_equipment_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.equipment.plannedAircraftType": 1,
        "flightLegState.equipment.aircraft": 1,
        "flightLegState.equipment.aircraftConfiguration": 1,
        "flightLegState.equipment.aircraftRegistration": 1,
        "flightLegState.equipment.assignedAircraftTypeIATA": 1,
        "flightLegState.equipment.assignedAircraftTypeICAO": 1,
        "flightLegState.equipment.assignedAircraftTypeIndigo": 1,
        "flightLegState.equipment.assignedAircraftConfiguration": 1,
        "flightLegState.equipment.tailLock": 1,
        "flightLegState.equipment.onwardFlight": 1,
        "flightLegState.equipment.actualOnwardFlight": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_delay_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Summarize delay reasons, durations, and total delay time for a specific flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_delay_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
   
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.operation.actualTimes.offBlock": 1,
        "flightLegState.delays": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_fuel_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Retrieve fuel summary including planned vs actual fuel for takeoff, landing, and total consumption.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_fuel_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
       
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.operation.fuel": 1,
        "flightLegState.operation.flightPlan.offBlockFuel": 1,
        "flightLegState.operation.flightPlan.takeoffFuel": 1,
        "flightLegState.operation.flightPlan.landingFuel": 1,
        "flightLegState.operation.flightPlan.holdFuel": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_passenger_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get passenger count and connection information for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_passenger_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.pax": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_crew_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get crew connections and details for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_crew_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.crewConnections": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def raw_mongodb_query(query_json: str, limit: int = 10) -> str:
    """
    Execute a raw MongoDB query (stringified JSON) generated by the LLM or user.

    Supports only read/find operations ‚Äî no write, delete, or aggregation commands.
    Automatically cleans and validates the input for safety.
    """

    def _safe_json_loads(text: str) -> dict:
        """Convert query string to JSON safely (handles single quotes and minor LLM mistakes)."""
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            try:
                fixed = text.replace("'", '"')
                return json.loads(fixed)
            except Exception as e:
                raise ValueError(f"Invalid JSON query: {e}")

    try:
        _, _, col = await get_mongodb_client()

       
        try:
            query = _safe_json_loads(query_json)
        except ValueError as e:
            return response_error(f"‚ùå Invalid JSON query. {str(e)}", 400)

       
        if not isinstance(query, dict):
            return response_error("‚ùå Query must be a JSON object.", 400)

        
        forbidden_ops = ["$where", "$out", "$merge", "$accumulator", "$function"]
        for key in query.keys():
            if key in forbidden_ops or key.startswith("$"):
                return response_error(f"‚ùå Operator '{key}' is not allowed.", 400)

        
        limit = min(max(1, int(limit)), 50)

        logger.info(f"Executing safe MongoDB query: {query} | limit={limit}")

        
        cursor = col.find(query).sort("flightLegState.dateOfOrigin", -1).limit(limit)
        docs = []
        async for doc in cursor:
            doc.pop("_id", None)
            doc.pop("_class", None)
            docs.append(doc)

       
        if not docs:
            return response_error("No documents found for the given query.", 404)

        return response_ok({"count": len(docs), "documents": docs})

    except Exception as exc:
        logger.exception("‚ùå raw_mongodb_query failed")
        return response_error(f"Raw MongoDB query failed: {str(exc)}", 500)


# --- Run MCP Server ---
if __name__ == "__main__":
    logger.info("Starting FlightOps MCP Server on %s:%s (transport=%s)", HOST, PORT, TRANSPORT)
    logger.info("MongoDB URL: %s, Database: %s, Collection: %s", MONGODB_URL, DATABASE_NAME, COLLECTION_NAME)
    mcp.run(transport="streamable-http")
  #########################################################################
import os
import json
import logging
import asyncio
from typing import List, Dict, Any

from dotenv import load_dotenv
from openai import AzureOpenAI
from mcp import ClientSession
from mcp.client.streamable_http import streamablehttp_client

from tool_registry import TOOLS

# Load environment variables
load_dotenv()

MCP_SERVER_URL = os.getenv("MCP_SERVER_URL", "http://127.0.0.1:8000").rstrip("/")

# Azure OpenAI configuration
AZURE_OPENAI_KEY = os.getenv("AZURE_OPENAI_KEY")
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4o")
AZURE_API_VERSION = os.getenv("AZURE_API_VERSION", "2024-12-01-preview")

if not AZURE_OPENAI_KEY:
    raise RuntimeError("‚ùå AZURE_OPENAI_KEY not set in environment")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("FlightOps.MCPClient")

# Initialize Azure OpenAI client
client_azure = AzureOpenAI(
    api_key=AZURE_OPENAI_KEY,
    api_version=AZURE_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)

# ---------------------------------------------------------------------
#  SYSTEM PROMPTS
# ---------------------------------------------------------------------
def _build_tool_prompt() -> str:
    """Convert TOOLS dict into compact text to feed the LLM."""
    lines = []
    for name, meta in TOOLS.items():
        arg_str = ", ".join(meta["args"])
        lines.append(f"- {name}({arg_str}): {meta['desc']}")
    return "\n".join(lines)


SYSTEM_PROMPT_PLAN = f"""
You are an assistant that converts user questions into MCP tool calls.

Available tools:
{_build_tool_prompt()}

You may also generate a MongoDB query directly when the question is complex
(e.g., involves filtering, ranges, aggregation, or comparisons between flights).

When using 'raw_mongodb_query':
- Always include a key "query_json" as a valid MongoDB query (stringified JSON).
- Optionally include "limit" to restrict results.
- Use fields defined in the schema (like flightLegState.carrier, startStation, delays.total, etc).
- Never invent fields or operators.
- Use JSON, not Mongo shell syntax.
- for passenger information in mongodb its in "flightLegState.pax.passengerCount" 
- always

Example valid output:
{{
  "plan": [
    {{
      "tool": "raw_mongodb_query",
      "arguments": {{
        "query_json": "{{ 'flightLegState.startStation': 'DEL', 'flightLegState.endStation': 'BOM', 'flightLegState.delays.total': {{ '$gt': '00:30' }} }}",
        "limit": 10
      }}
    }}
  ]
}}

Rules:
1. Output only valid JSON.
2. Always return a top-level key 'plan' as a list.
3. If the query is simple (single flight or delay info), use existing tools.
4. If it‚Äôs complex, use raw_mongodb_query.
5. Do not invent tool names.
"""

SYSTEM_PROMPT_SUMMARIZE = """
You are an assistant that summarizes tool outputs into a concise, readable answer.
Be factual, short, and helpful.
"""

# ---------------------------------------------------------------------
#  FLIGHTOPS MCP CLIENT CLASS
# ---------------------------------------------------------------------
class FlightOpsMCPClient:
    def __init__(self, base_url: str = None):
        self.base_url = (base_url or MCP_SERVER_URL).rstrip("/")
        self.session: ClientSession = None
        self._client_context = None

    # -------------------- CONNECTION HANDLERS -------------------------
    async def connect(self):
        try:
            logger.info(f"Connecting to MCP server at {self.base_url}")
            self._client_context = streamablehttp_client(self.base_url)
            read_stream, write_stream, _ = await self._client_context.__aenter__()
            self.session = ClientSession(read_stream, write_stream)
            await self.session.__aenter__()
            await self.session.initialize()
            logger.info("‚úÖ Connected to MCP server successfully")
        except Exception as e:
            logger.error(f"Failed to connect to MCP server: {e}")
            raise

    async def disconnect(self):
        try:
            if self.session:
                await self.session.__aexit__(None, None, None)
            if self._client_context:
                await self._client_context.__aexit__(None, None, None)
            logger.info("Disconnected from MCP server")
        except Exception as e:
            logger.error(f"Error during disconnect: {e}")

    # -------------------- AZURE OPENAI WRAPPER -------------------------
    def _call_azure_openai(self, messages: list, temperature: float = 0.2, max_tokens: int = 2048) -> str:
        try:
            completion = client_azure.chat.completions.create(
                model=AZURE_OPENAI_DEPLOYMENT,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
            )
            return completion.choices[0].message.content
        except Exception as e:
            logger.error(f"Azure OpenAI API error: {e}")
            return json.dumps({"error": str(e)})

    # -------------------- MCP TOOL CALLS -------------------------
    async def list_tools(self) -> dict:
        try:
            if not self.session:
                await self.connect()
            tools_list = await self.session.list_tools()
            tools_dict = {tool.name: {"description": tool.description, "inputSchema": tool.inputSchema} for tool in tools_list.tools}
            return {"tools": tools_dict}
        except Exception as e:
            logger.error(f"Error listing tools: {e}")
            return {"error": str(e)}

    async def invoke_tool(self, tool_name: str, args: dict) -> dict:
        try:
            if not self.session:
                await self.connect()
            logger.info(f"Calling tool: {tool_name} with args: {args}")
            result = await self.session.call_tool(tool_name, args)

            if result.content:
                content_items = []
                for item in result.content:
                    if hasattr(item, 'text'):
                        try:
                            content_items.append(json.loads(item.text))
                        except json.JSONDecodeError:
                            content_items.append(item.text)
                if len(content_items) == 1:
                    return content_items[0]
                return {"results": content_items}

            return {"error": "No content in response"}
        except Exception as e:
            logger.error(f"Error invoking tool {tool_name}: {e}")
            return {"error": str(e)}

    # -------------------- LLM PLANNING & SUMMARIZATION -------------------------
    def plan_tools(self, user_query: str) -> dict:
        """
        Ask the LLM to produce a valid JSON plan for which MCP tools to call.
        Cleans out Markdown-style fences (```json ... ```), which some models add.
        """
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_PLAN},
            {"role": "user", "content": user_query},
        ]

        content = self._call_azure_openai(messages, temperature=0.1)
        if not content:
            logger.warning("‚ö†Ô∏è LLM returned empty response during plan generation.")
            return {"plan": []}

        
        cleaned = content.strip()
        if cleaned.startswith("```"):
            
            cleaned = cleaned.strip("`")
            if cleaned.lower().startswith("json"):
                cleaned = cleaned[4:].strip()
            
            cleaned = cleaned.replace("```", "").strip()

        
        if cleaned != content:
            logger.debug(f"üîç Cleaned LLM plan output:\n{cleaned}")

       
        try:
            plan = json.loads(cleaned)
            if isinstance(plan, dict) and "plan" in plan:
                return plan
            else:
                logger.warning("‚ö†Ô∏è LLM output did not contain 'plan' key.")
                return {"plan": []}
        except json.JSONDecodeError:
            logger.warning(f"‚ùå Could not parse LLM plan output after cleaning:\n{cleaned}")
            return {"plan": []}


    def summarize_results(self, user_query: str, plan: list, results: list) -> dict:
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_SUMMARIZE},
            {"role": "user", "content": f"Question:\n{user_query}"},
            {"role": "assistant", "content": f"Plan:\n{json.dumps(plan, indent=2)}"},
            {"role": "assistant", "content": f"Results:\n{json.dumps(results, indent=2)}"},
        ]
        summary = self._call_azure_openai(messages, temperature=0.3)
        return {"summary": summary}

   
    async def run_query(self, user_query: str) -> dict:
        """
        Full flow:
        1. LLM plans which tools to call (including possible MongoDB query).
        2. Execute tools sequentially via MCP.
        3. Summarize results using LLM.
        """
        try:
            logger.info(f"User query: {user_query}")
            plan_data = self.plan_tools(user_query)
            plan = plan_data.get("plan", [])
            if not plan:
                return {"error": "LLM did not produce a valid tool plan."}

            results = []
            for step in plan:
                tool = step.get("tool")
                args = step.get("arguments", {})

                # Clean up bad args
                args = {k: v for k, v in args.items() if v and str(v).strip().lower() != "unknown"}

                # Safety for MongoDB query
                if tool == "raw_mongodb_query":
                    query_json = args.get("query_json", "")
                    if not query_json:
                        results.append({"raw_mongodb_query": {"error": "Empty query_json"}})
                        continue
                    # Enforce safe default limit
                    args["limit"] = int(args.get("limit", 50))
                    logger.info(f"Executing raw MongoDB query: {query_json}")

                resp = await self.invoke_tool(tool, args)
                results.append({tool: resp})

            summary = self.summarize_results(user_query, plan, results)
            return {"plan": plan, "results": results, "summary": summary}
        except Exception as e:
            logger.error(f"Error in run_query: {e}")
            return {"error": str(e)}
#####################################################################
# tool_registry.py

TOOLS = {
    "get_flight_basic_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Fetch basic flight information including carrier, flight number, stations, scheduled times, and flight status.",
    },
    "get_equipment_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get aircraft equipment details: aircraft type, tail number (registration), and configuration.",
    },
    "get_operation_times": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Return estimated and actual operation times: takeoff, landing, departure, arrival, and block times.",
    },
    "get_fuel_summary": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Retrieve fuel summary including planned vs actual fuel consumption for the flight.",
    },
    "get_delay_summary": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get delay information including delay reasons, durations, and total delay time.",
    },
    "health_check": {
        "args": [],
        "desc": "Check the health status of the MCP server and database connection.",
    },
    "raw_mongodb_query": {
        "args": ["query_json", "limit"],
        "desc": "Run a raw MongoDB query (JSON format) for debugging purposes.",
    },
}
############################################################################
# ag_ui_encoder_server.py
import os
import uuid
import json
import asyncio
from typing import List, Any, Optional, AsyncGenerator, Dict
from datetime import datetime
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv

# Import AG-UI Core Events and Encoder
from ag_ui.core import (
    RunAgentInput, UserMessage, Tool, Context, State,
    EventType, RunStartedEvent, RunFinishedEvent, RunErrorEvent,
    StepStartedEvent, StepFinishedEvent, TextMessageStartEvent,
    TextMessageContentEvent, TextMessageEndEvent, ToolCallStartEvent,
    StateSnapshotEvent, StateDeltaEvent, MessagesSnapshotEvent,
    CustomEvent
)

from ag_ui.encoder import EventEncoder

# Import your MCP client
from mcp_client import FlightOpsMCPClient
from tool_registry import TOOLS

load_dotenv()

app = FastAPI(title="FlightOps AG-UI Encoder Server")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

class FlightOpsEncoderAgent:
    def __init__(self):
        self.mcp_client = FlightOpsMCPClient()
        self._connected = False
        self._session_state = {}

    async def connect(self):
        if not self._connected:
            await self.mcp_client.connect()
            self._connected = True

    def _get_timestamp(self) -> int:
        """Get current timestamp in milliseconds"""
        return int(datetime.now().timestamp() * 1000)

    def _create_agui_tools(self) -> List[Tool]:
        """Convert MCP tools to AG-UI Tool format"""
        agui_tools = []
        
        for tool_name, tool_meta in TOOLS.items():
            properties = {}
            for arg in tool_meta["args"]:
                properties[arg] = {"type": "string"}
            
            parameters = {
                "type": "object",
                "properties": properties,
                "required": tool_meta["args"]
            }
            
            agui_tool = Tool(
                name=tool_name,
                description=tool_meta["desc"],
                parameters=parameters
            )
            agui_tools.append(agui_tool)
        
        return agui_tools

    async def process_agent_input(self, input_data: RunAgentInput, encoder: EventEncoder) -> AsyncGenerator[str, None]:
        """Process AG-UI input and yield properly encoded events"""
        try:
            # Update session state
            self._session_state["current_run"] = input_data.run_id
            self._session_state["active_thread"] = input_data.thread_id

            # 1. Emit RUN_STARTED event
            yield encoder.encode(RunStartedEvent(
                type=EventType.RUN_STARTED,
                timestamp=self._get_timestamp(),
                thread_id=input_data.thread_id,
                run_id=input_data.run_id
            ))

            # 2. Emit initial state snapshot
            yield encoder.encode(StateSnapshotEvent(
                type=EventType.STATE_SNAPSHOT,
                timestamp=self._get_timestamp(),
                snapshot={
                    "thread_id": input_data.thread_id,
                    "session_start": datetime.now().isoformat(),
                    "tools_available": list(TOOLS.keys()),
                    "last_activity": datetime.now().isoformat(),
                    **self._session_state
                }
            ))

            # 3. Emit messages snapshot
            yield encoder.encode(MessagesSnapshotEvent(
                type=EventType.MESSAGES_SNAPSHOT,
                timestamp=self._get_timestamp(),
                messages=input_data.messages
            ))

            # 4. STEP: Connect to MCP
            yield encoder.encode(StepStartedEvent(
                type=EventType.STEP_STARTED,
                timestamp=self._get_timestamp(),
                step_name="connect_mcp_client"
            ))

            await self.connect()

            yield encoder.encode(StepFinishedEvent(
                type=EventType.STEP_FINISHED,
                timestamp=self._get_timestamp(),
                step_name="connect_mcp_client"
            ))

            # 5. Get user message
            user_message = None
            for msg in reversed(input_data.messages):
                if isinstance(msg, UserMessage):
                    user_message = msg.content
                    break

            if not user_message:
                raise ValueError("No user message found")

            # 6. STEP: Process flight query
            yield encoder.encode(StepStartedEvent(
                type=EventType.STEP_STARTED,
                timestamp=self._get_timestamp(),
                step_name="process_flight_query"
            ))

            # 7. Emit TEXT_MESSAGE_START
            message_id = f"msg-{uuid.uuid4().hex[:8]}"
            yield encoder.encode(TextMessageStartEvent(
                type=EventType.TEXT_MESSAGE_START,
                timestamp=self._get_timestamp(),
                message_id=message_id,
                role="assistant"
            ))

            # 8. Process the query with MCP client
            mcp_result = await self.mcp_client.run_query(user_message)
            
            # Update state with query result metadata
            self._session_state["last_query"] = user_message
            self._session_state["last_result_type"] = "flight_data"

            # 9. Emit state delta for the update
            yield encoder.encode(StateDeltaEvent(
                type=EventType.STATE_DELTA,
                timestamp=self._get_timestamp(),
                delta=[
                    {
                        "op": "add",
                        "path": "/last_query",
                        "value": user_message
                    },
                    {
                        "op": "add", 
                        "path": "/last_result_type",
                        "value": "flight_data"
                    }
                ]
            ))

            # 10. Extract and stream response
            response_text = ""
            if "summary" in mcp_result:
                response_text = mcp_result["summary"]
            elif "error" in mcp_result:
                response_text = f"Error: {mcp_result['error']}"
                # Emit custom error event
                yield encoder.encode(CustomEvent(
                    type=EventType.CUSTOM,
                    timestamp=self._get_timestamp(),
                    name="flight_query_error",
                    value={"error": mcp_result["error"], "query": user_message}
                ))
            else:
                response_text = "I've processed your flight data query using our database tools."

            # 11. Stream text content with proper chunking using EventEncoder
            words = response_text.split()
            for i, word in enumerate(words):
                yield encoder.encode(TextMessageContentEvent(
                    type=EventType.TEXT_MESSAGE_CONTENT,
                    timestamp=self._get_timestamp(),
                    message_id=message_id,
                    delta=word + (" " if i < len(words) - 1 else "")
                ))
                await asyncio.sleep(0.02)

            # 12. Emit TEXT_MESSAGE_END
            yield encoder.encode(TextMessageEndEvent(
                type=EventType.TEXT_MESSAGE_END,
                timestamp=self._get_timestamp(),
                message_id=message_id
            ))

            # 13. STEP: Finalize processing
            yield encoder.encode(StepFinishedEvent(
                type=EventType.STEP_FINISHED,
                timestamp=self._get_timestamp(),
                step_name="process_flight_query"
            ))

            # 14. Emit final state snapshot
            yield encoder.encode(StateSnapshotEvent(
                type=EventType.STATE_SNAPSHOT,
                timestamp=self._get_timestamp(),
                snapshot={
                    "thread_id": input_data.thread_id,
                    "session_start": datetime.now().isoformat(),
                    "tools_available": list(TOOLS.keys()),
                    "last_activity": datetime.now().isoformat(),
                    "query_completed": True,
                    **self._session_state
                }
            ))

            # 15. Emit RUN_FINISHED with result
            yield encoder.encode(RunFinishedEvent(
                type=EventType.RUN_FINISHED,
                timestamp=self._get_timestamp(),
                thread_id=input_data.thread_id,
                run_id=input_data.run_id,
                result={
                    "status": "success",
                    "query_type": "flight_operations",
                    "response_length": len(response_text),
                    "tools_used": list(TOOLS.keys()) if "summary" in mcp_result else []
                }
            ))

        except Exception as error:
            # Emit RUN_ERROR event using encoder
            yield encoder.encode(RunErrorEvent(
                type=EventType.RUN_ERROR,
                timestamp=self._get_timestamp(),
                message=str(error),
                code="AGENT_EXECUTION_ERROR"
            ))

            # Emit custom error event for debugging
            yield encoder.encode(CustomEvent(
                type=EventType.CUSTOM,
                timestamp=self._get_timestamp(),
                name="agent_execution_failed",
                value={"error": str(error), "run_id": input_data.run_id}
            ))

# Global agent instance
agent = FlightOpsEncoderAgent()

@app.post("/agent")
async def flight_agent_endpoint(request: Request):
    """AG-UI endpoint using proper EventEncoder for SSE formatting"""
    try:
        # Parse request body as RunAgentInput
        body = await request.json()
        input_data = RunAgentInput(**body)
        
        # Get Accept header for encoder
        accept_header = request.headers.get("accept", "text/event-stream")
        
        # Initialize EventEncoder with client's Accept header
        encoder = EventEncoder(accept=accept_header)
        
        print(f"üéØ Starting AG-UI run with EventEncoder:")
        print(f"   Thread: {input_data.thread_id}")
        print(f"   Run: {input_data.run_id}")
        print(f"   Messages: {len(input_data.messages)}")
        print(f"   Encoder Content-Type: {encoder.get_content_type()}")

        async def event_generator() -> AsyncGenerator[str, None]:
            async for encoded_event in agent.process_agent_input(input_data, encoder):
                yield encoded_event

        return StreamingResponse(
            event_generator(),
            media_type=encoder.get_content_type(),
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Access-Control-Allow-Origin": "*",
                "X-AG-UI-Version": "1.0",
                "X-Event-Encoder": "enabled"
            }
        )

    except Exception as e:
        print(f"‚ùå Server error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/")
async def health_check():
    return {
        "status": "healthy", 
        "service": "FlightOps AG-UI Encoder Server",
        "encoder": "EventEncoder enabled",
        "supported_tools": list(TOOLS.keys())
    }

@app.get("/tools")
async def list_agui_tools():
    """List tools in AG-UI format"""
    tools = agent._create_agui_tools()
    return {
        "tools": [tool.model_dump() for tool in tools]
    }

@app.get("/encoder/test")
async def encoder_test_endpoint():
    """Test endpoint to demonstrate EventEncoder functionality"""
    
    # Create test events
    test_events = []
    encoder = EventEncoder()
    
    # Test different event types
    test_events.append(encoder.encode(RunStartedEvent(
        type=EventType.RUN_STARTED,
        thread_id="test-thread",
        run_id="test-run"
    )))
    
    test_events.append(encoder.encode(TextMessageStartEvent(
        type=EventType.TEXT_MESSAGE_START,
        message_id="test-msg",
        role="assistant"
    )))
    
    test_events.append(encoder.encode(TextMessageContentEvent(
        type=EventType.TEXT_MESSAGE_CONTENT,
        message_id="test-msg", 
        delta="Hello from EventEncoder!"
    )))
    
    test_events.append(encoder.encode(TextMessageEndEvent(
        type=EventType.TEXT_MESSAGE_END,
        message_id="test-msg"
    )))
    
    test_events.append(encoder.encode(RunFinishedEvent(
        type=EventType.RUN_FINISHED,
        thread_id="test-thread",
        run_id="test-run"
    )))
    
    return {
        "encoder_test": True,
        "content_type": encoder.get_content_type(),
        "sample_events": test_events
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("ag_ui_encoder_server:app", host="0.0.0.0", port=8001, reload=True)
####################################################################
# ag_ui_encoder_client.py
import asyncio
import httpx
import json
from datetime import datetime
from typing import Dict, Any
import uuid

class EncoderAwareClient:
    def __init__(self, base_url: str = "http://localhost:8001"):
        self.base_url = base_url
        
    async def test_encoder_directly(self):
        """Test the EventEncoder functionality directly"""
        print("üîß Testing EventEncoder Directly")
        print("=" * 50)
        
        try:
            # Test the encoder test endpoint
            async with httpx.AsyncClient() as client:
                response = await client.get(f"{self.base_url}/encoder/test")
                if response.status_code == 200:
                    data = response.json()
                    print(f"‚úÖ Encoder test endpoint: {data['encoder_test']}")
                    print(f"üìß Content-Type: {data['content_type']}")
                    print(f"üì® Sample events: {len(data['sample_events'])}")
                    
                    # Display sample event format
                    if data['sample_events']:
                        print(f"\nüìù Sample Event Format:")
                        print(data['sample_events'][0])
                else:
                    print(f"‚ùå Encoder test failed: {response.status_code}")
        except Exception as e:
            print(f"‚ùå Encoder test error: {e}")
    
    async def test_full_event_stream(self):
        """Test the full event stream with proper SSE parsing"""
        print(f"\nüéØ Testing Full Event Stream with EventEncoder")
        print("=" * 50)
        
        # Create test request
        test_input = {
            "thread_id": f"encoder-test-{uuid.uuid4().hex[:8]}",
            "run_id": f"run-{int(datetime.now().timestamp())}",
            "state": {"test": "encoder_validation"},
            "messages": [{
                "id": f"msg-{int(datetime.now().timestamp())}",
                "role": "user",
                "content": "What's the basic information for flight 6E 215 on 2024-06-23?"
            }],
            "tools": [],
            "context": [],
            "forwarded_props": {}
        }
        
        print(f"üì§ Request: Thread={test_input['thread_id']}, Run={test_input['run_id']}")
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            try:
                async with client.stream(
                    "POST",
                    f"{self.base_url}/agent",
                    json=test_input,
                    headers={
                        "Accept": "text/event-stream",
                        "Content-Type": "application/json",
                        "X-Test-Client": "EncoderAwareClient"
                    }
                ) as response:
                    print(f"üîó Connection: {response.status_code}")
                    
                    if response.status_code != 200:
                        error_body = await response.aread()
                        print(f"‚ùå Server error: {error_body}")
                        return
                    
                    # Check response headers
                    content_type = response.headers.get('content-type', '')
                    print(f"üìß Response Content-Type: {content_type}")
                    print(f"üîß Encoder Header: {response.headers.get('x-event-encoder', 'not set')}")
                    
                    # Parse SSE events
                    event_count = 0
                    async for line in response.aiter_lines():
                        line = line.strip()
                        
                        # Skip empty lines and comments
                        if not line or line.startswith(':'):
                            continue
                            
                        if line.startswith('data: '):
                            event_count += 1
                            event_data = line[6:]  # Remove 'data: ' prefix
                            
                            try:
                                event = json.loads(event_data)
                                event_type = event.get('type', 'UNKNOWN')
                                
                                # Display event information
                                if event_type == 'RUN_STARTED':
                                    print(f"üöÄ {event_type}: {event.get('run_id')}")
                                elif event_type == 'TEXT_MESSAGE_START':
                                    print(f"üí¨ {event_type}: ", end='', flush=True)
                                elif event_type == 'TEXT_MESSAGE_CONTENT':
                                    print(event.get('delta', ''), end='', flush=True)
                                elif event_type == 'TEXT_MESSAGE_END':
                                    print()  # New line
                                elif event_type == 'RUN_FINISHED':
                                    print(f"‚úÖ {event_type}: {event.get('result', {})}")
                                elif event_type == 'STATE_SNAPSHOT':
                                    print(f"üìä {event_type}: state updated")
                                elif event_type == 'STEP_STARTED':
                                    print(f"   üîÑ {event_type}: {event.get('step_name')}")
                                else:
                                    print(f"   üì® {event_type}")
                                    
                            except json.JSONDecodeError as e:
                                print(f"   ‚ùå JSON Error in event: {e}")
                                print(f"   Raw data: {event_data[:100]}...")
                    
                    print(f"\nüìà Event Stream Complete:")
                    print(f"   Total events processed: {event_count}")
                    
            except Exception as e:
                print(f"‚ùå Stream error: {e}")
    
    async def test_multiple_encodings(self):
        """Test different Accept headers and encoding options"""
        print(f"\nüéõÔ∏è Testing Different Encodings")
        print("=" * 50)
        
        test_accept_headers = [
            "text/event-stream",
            "application/json",
            "application/x-ndjson",
            "*/*"
        ]
        
        for accept_header in test_accept_headers:
            print(f"\nüîß Testing Accept: {accept_header}")
            
            test_input = {
                "thread_id": f"encoding-test-{uuid.uuid4().hex[:4]}",
                "run_id": f"run-{int(datetime.now().timestamp())}",
                "state": {},
                "messages": [{
                    "id": f"msg-{int(datetime.now().timestamp())}",
                    "role": "user",
                    "content": "Quick health check"
                }],
                "tools": [],
                "context": [],
                "forwarded_props": {}
            }
            
            try:
                async with httpx.AsyncClient(timeout=30.0) as client:
                    async with client.stream(
                        "POST",
                        f"{self.base_url}/agent",
                        json=test_input,
                        headers={
                            "Accept": accept_header,
                            "Content-Type": "application/json"
                        }
                    ) as response:
                        content_type = response.headers.get('content-type', 'unknown')
                        print(f"   üìß Response Content-Type: {content_type}")
                        print(f"   üîó Status: {response.status_code}")
                        
                        # Read a few lines to see format
                        line_count = 0
                        async for line in response.aiter_lines():
                            if line_count < 3 and line.strip():
                                print(f"   üìù Sample: {line[:100]}...")
                                line_count += 1
                            if line_count >= 3:
                                break
                                
            except Exception as e:
                print(f"   ‚ùå Error: {e}")

async def run_comprehensive_encoder_test():
    """Run comprehensive EventEncoder tests"""
    
    client = EncoderAwareClient()
    
    print("üî¨ COMPREHENSIVE EVENTENCODER TEST SUITE")
    print("Testing AG-UI EventEncoder for proper SSE formatting")
    
    # 1. Test encoder directly
    await client.test_encoder_directly()
    
    # 2. Test full event stream
    await client.test_full_event_stream()
    
    # 3. Test different encodings
    await client.test_multiple_encodings()
    
    print(f"\nüéâ EventEncoder Testing Complete!")
    print("The AG-UI server is now properly encoding events for HTTP streaming.")

if __name__ == "__main__":
    asyncio.run(run_comprehensive_encoder_test())
###############################################################
# encoder_validator.py
import asyncio
import httpx
import json
from datetime import datetime

class EventEncoderValidator:
    def __init__(self, base_url: str = "http://localhost:8001"):
        self.base_url = base_url
        
    async def validate_sse_format(self):
        """Validate that events are properly formatted as Server-Sent Events"""
        print("üîç Validating SSE Event Format")
        print("=" * 50)
        
        test_input = {
            "thread_id": "validator-thread",
            "run_id": f"validate-{int(datetime.now().timestamp())}",
            "state": {},
            "messages": [{
                "id": "validate-msg-1",
                "role": "user", 
                "content": "Test message for SSE validation"
            }],
            "tools": [],
            "context": [],
            "forwarded_props": {}
        }
        
        issues = []
        events_received = 0
        
        async with httpx.AsyncClient(timeout=30.0) as client:
            try:
                async with client.stream(
                    "POST",
                    f"{self.base_url}/agent",
                    json=test_input,
                    headers={"Accept": "text/event-stream"}
                ) as response:
                    
                    if response.status_code != 200:
                        issues.append(f"Invalid status code: {response.status_code}")
                        return issues
                    
                    # Check Content-Type header
                    content_type = response.headers.get('content-type', '')
                    if 'text/event-stream' not in content_type:
                        issues.append(f"Invalid Content-Type: {content_type}")
                    
                    # Validate SSE format
                    async for line in response.aiter_lines():
                        line = line.strip()
                        
                        if not line:
                            continue
                            
                        # Check SSE format
                        if line.startswith('data: '):
                            events_received += 1
                            event_data = line[6:]
                            
                            # Validate JSON format
                            try:
                                event = json.loads(event_data)
                                
                                # Check required fields
                                if 'type' not in event:
                                    issues.append("Event missing 'type' field")
                                    
                                # Validate event structure based on type
                                event_type = event.get('type')
                                if event_type == 'TEXT_MESSAGE_CONTENT':
                                    if 'delta' not in event:
                                        issues.append("TEXT_MESSAGE_CONTENT missing 'delta'")
                                    elif event['delta'] == "":
                                        issues.append("TEXT_MESSAGE_CONTENT has empty delta")
                                        
                            except json.JSONDecodeError as e:
                                issues.append(f"Invalid JSON in event: {e}")
                                
                        elif not line.startswith(':') and not line.startswith('data: '):
                            issues.append(f"Invalid SSE line format: {line}")
                    
            except Exception as e:
                issues.append(f"Connection error: {e}")
        
        # Summary
        print(f"üìä Validation Results:")
        print(f"   Events processed: {events_received}")
        print(f"   Issues found: {len(issues)}")
        
        if issues:
            print("‚ùå Validation Issues:")
            for issue in issues[:5]:  # Show first 5 issues
                print(f"   - {issue}")
            if len(issues) > 5:
                print(f"   ... and {len(issues) - 5} more issues")
        else:
            print("‚úÖ All events properly formatted as SSE!")
            
        return issues, events_received
    
    async def benchmark_event_stream(self):
        """Benchmark event streaming performance"""
        print(f"\n‚ö° Benchmarking Event Stream Performance")
        print("=" * 50)
        
        test_input = {
            "thread_id": "benchmark-thread",
            "run_id": f"benchmark-{int(datetime.now().timestamp())}",
            "state": {},
            "messages": [{
                "id": "benchmark-msg-1",
                "role": "user",
                "content": "Please provide detailed flight information for benchmarking purposes"
            }],
            "tools": [],
            "context": [],
            "forwarded_props": {}
        }
        
        start_time = datetime.now()
        event_count = 0
        total_bytes = 0
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            try:
                async with client.stream(
                    "POST",
                    f"{self.base_url}/agent",
                    json=test_input,
                    headers={"Accept": "text/event-stream"}
                ) as response:
                    
                    async for line in response.aiter_lines():
                        if line.startswith('data: '):
                            event_count += 1
                            total_bytes += len(line)
                            
            except Exception as e:
                print(f"‚ùå Benchmark error: {e}")
                return
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        print(f"üìà Benchmark Results:")
        print(f"   Duration: {duration:.2f} seconds")
        print(f"   Events: {event_count}")
        print(f"   Data: {total_bytes} bytes")
        print(f"   Events/sec: {event_count/duration:.2f}" if duration > 0 else "N/A")
        print(f"   KB/sec: {(total_bytes/1024)/duration:.2f}" if duration > 0 else "N/A")

async def main():
    validator = EventEncoderValidator()
    
    print("üéØ AG-UI EventEncoder Validation Suite")
    print("Validating proper Server-Sent Events formatting")
    
    # Run validation
    issues, event_count = await validator.validate_sse_format()
    
    # Run benchmark if validation passed
    if not issues:
        await validator.benchmark_event_stream()
    
    print(f"\n{'‚úÖ VALIDATION COMPLETE' if not issues else 'ÔøΩÔ∏è VALIDATION FAILED'}")

if __name__ == "__main__":
    asyncio.run(main())
#####################################################################################
(venv66) PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python server.py
INFO:flightops.mcp.server:Starting FlightOps MCP Server on 127.0.0.1:8000 (transport=streamable-http)
INFO:flightops.mcp.server:MongoDB URL: mongodb+srv://joc-dbuser:n5cqzIJSl319TZN6@mongo-airlineops-az-ddb01-pl-0.npznw.mongodb.net/, Database: jocflightdb_30jan, Collection: flight
INFO:     Started server process [25872]
INFO:     Waiting for application startup.
INFO:mcp.server.streamable_http_manager:StreamableHTTP session manager started
INFO:     Application startup complete.
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:mcp.server.streamable_http_manager:Created new transport with session ID: 78cbf09137aa4a8782ea6467ba5dc51e
INFO:     127.0.0.1:55920 - "POST /mcp HTTP/1.1" 200 OK
INFO:     127.0.0.1:55923 - "POST /mcp HTTP/1.1" 202 Accepted
INFO:     127.0.0.1:55924 - "GET /mcp HTTP/1.1" 200 OK
INFO:     127.0.0.1:55925 - "POST /mcp HTTP/1.1" 200 OK
INFO:mcp.server.lowlevel.server:Processing request of type CallToolRequest
INFO:flightops.mcp.server:Connecting to MongoDB: mongodb+srv://joc-dbuser:n5cqzIJSl319TZN6@mongo-airlineops-az-ddb01-pl-0.npznw.mongodb.net/
INFO:     127.0.0.1:55932 - "POST /mcp HTTP/1.1" 200 OK
INFO:mcp.server.lowlevel.server:Processing request of type ListToolsRequest
#################################################################################################
PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui> cd backend
PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python validate_integration.py
üîç Validating FlightOps Integration
==================================================

1. Checking MCP Server (port 8000)...
   ‚úÖ MCP Server should be running on port 8000

2. Checking AG-UI Server (port 8001)...

1. Checking MCP Server (port 8000)...
   ‚úÖ MCP Server should be running on port 8000

2. Checking AG-UI Server (port 8001)...
1. Checking MCP Server (port 8000)...
   ‚úÖ MCP Server should be running on port 8000

2. Checking AG-UI Server (port 8001)...
   ‚úÖ MCP Server should be running on port 8000

2. Checking AG-UI Server (port 8001)...

2. Checking AG-UI Server (port 8001)...
2. Checking AG-UI Server (port 8001)...
   ‚úÖ AG-UI Server healthy: {'status': 'healthy', 'service': 'FlightOps AG-UI Server', 'openai_configured': True}

3. Checking MCP Tools Integration...
   ‚ùå Tools endpoint failed: 404

4. Testing Direct MCP Query...
   ‚ùå Direct query failed: 404

==================================================
üéØ Validation Complete!
Next: Run 'python ag_ui_client_enhanced.py' to test flight data queries
PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python .\validate_core_types.py    
Traceback (most recent call last):
  File "C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend\validate_core_types.py", line 4, in <module>
    from ag_ui.core import RunAgentInput, UserMessage, Tool, Context
ModuleNotFoundError: No module named 'ag_ui'
PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python .\encoder_validator.py
üéØ AG-UI EventEncoder Validation Suite
Validating proper Server-Sent Events formatting
üîç Validating SSE Event Format
==================================================
üìä Validation Results:
   Events processed: 10
   Issues found: 0
‚úÖ All events properly formatted as SSE!

‚ö° Benchmarking Event Stream Performance
==================================================
üìà Benchmark Results:
   Duration: 2.37 seconds
   Events: 10
   Data: 1728 bytes
   Events/sec: 4.21
   KB/sec: 0.71

‚úÖ VALIDATION COMPLETE
PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python .\encoder_validator.py
üéØ AG-UI EventEncoder Validation Suite
Validating proper Server-Sent Events formatting
üîç Validating SSE Event Format
==================================================
üìä Validation Results:
   Events processed: 10
   Issues found: 0
‚úÖ All events properly formatted as SSE!

‚ö° Benchmarking Event Stream Performance
==================================================
üìà Benchmark Results:
   Duration: 2.14 seconds
   Events: 10
   Data: 1728 bytes
   Events/sec: 4.67
   KB/sec: 0.79

‚úÖ VALIDATION COMPLETE
PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> 
######################################################################################################
(venv66) PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python .\ag_ui_proper_client.py
üî¨ FlightOps Proper AG-UI Integration Test
Using AG-UI Core Types for type-safe agent communication

üîß Testing AG-UI Tools Endpoint...
‚ùå Tools test failed: All connection attempts failed

Press Enter to start proper AG-UI tests...

============================================================
üöÄ PROPER AG-UI TEST 1: What's the status of flight 6E 215 on 2024-06-23?
============================================================
üîÑ Creating proper AG-UI request...
   Thread ID: flight-ops-thread
   Run ID: run-1762166950
   Tools: 2
‚ùå Error: All connection attempts failed

============================================================
üöÄ PROPER AG-UI TEST 2: Get equipment information for flight 6E 215
============================================================
üîÑ Creating proper AG-UI request...
   Thread ID: flight-ops-thread
   Run ID: run-1762166954
   Tools: 2
‚ùå Error: All connection attempts failed

============================================================
üöÄ PROPER AG-UI TEST 3: Show me the delay summary for flight 6E 215
============================================================
üîÑ Creating proper AG-UI request...
   Thread ID: flight-ops-thread
   Run ID: run-1762166958
   Tools: 2
‚ùå Error: All connection attempts failed

============================================================
üöÄ PROPER AG-UI TEST 4: What's the passenger count on flight 6E 215?
============================================================
üîÑ Creating proper AG-UI request...
üöÄ PROPER AG-UI TEST 4: What's the passenger count on flight 6E 215?
============================================================
üîÑ Creating proper AG-UI request...
üîÑ Creating proper AG-UI request...
   Thread ID: flight-ops-thread
   Run ID: run-1762166962
   Tools: 2
‚ùå Error: All connection attempts failed

============================================================
üöÄ PROPER AG-UI TEST 5: Get fuel summary for flight 6E 215 on 2024-06-23
============================================================
üîÑ Creating proper AG-UI request...
   Thread ID: flight-ops-thread
   Run ID: run-1762166966
   Tools: 2
‚ùå Error: All connection attempts failed
(venv66) PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python .\ag_ui_encoder_client.py
üî¨ COMPREHENSIVE EVENTENCODER TEST SUITE
Testing AG-UI EventEncoder for proper SSE formatting
üîß Testing EventEncoder Directly
==================================================
‚úÖ Encoder test endpoint: True
üìß Content-Type: text/event-stream
üì® Sample events: 5

üìù Sample Event Format:
data: {"type":"RUN_STARTED","threadId":"test-thread","runId":"test-run"}



üéØ Testing Full Event Stream with EventEncoder
==================================================
üì§ Request: Thread=encoder-test-3b93023c, Run=run-1762168487
üîó Connection: 200
üìß Response Content-Type: text/event-stream; charset=utf-8
üîß Encoder Header: enabled
üöÄ RUN_STARTED: None
üìä STATE_SNAPSHOT: state updated
   üì® MESSAGES_SNAPSHOT
   üîÑ STEP_STARTED: None
   üì® STEP_FINISHED
   üîÑ STEP_STARTED: None
üí¨ TEXT_MESSAGE_START:    üì® STATE_DELTA
   üì® RUN_ERROR
   üì® CUSTOM

üìà Event Stream Complete:
   Total events processed: 10

üéõÔ∏è Testing Different Encodings
==================================================

üîß Testing Accept: text/event-stream
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168491276,"threadId":"encoding-test-3368","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168491276,"snapshot":{"thread_id":"encoding-test-3368...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168491276,"messages":[{"id":"msg-1762168490","role...

üîß Testing Accept: application/json
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168492526,"threadId":"encoding-test-29d6","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168492526,"snapshot":{"thread_id":"encoding-test-29d6...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168492526,"messages":[{"id":"msg-1762168491","role...

üîß Testing Accept: application/x-ndjson
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168493653,"threadId":"encoding-test-de24","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168493653,"snapshot":{"thread_id":"encoding-test-de24...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168493653,"messages":[{"id":"msg-1762168492","role...

üîß Testing Accept: */*
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168494680,"threadId":"encoding-test-b2a5","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168494680,"snapshot":{"thread_id":"encoding-test-b2a5...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168494680,"messages":[{"id":"msg-1762168493","role...

üéâ EventEncoder Testing Complete!
The AG-UI server is now properly encoding events for HTTP streaming.                                   python .\ag_ui_encoder_client.py6) PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend>
üî¨ COMPREHENSIVE EVENTENCODER TEST SUITE
Testing AG-UI EventEncoder for proper SSE formatting
üîß Testing EventEncoder Directly
==================================================
‚úÖ Encoder test endpoint: True
üìß Content-Type: text/event-stream
üì® Sample events: 5

üìù Sample Event Format:
data: {"type":"RUN_STARTED","threadId":"test-thread","runId":"test-run"}



üéØ Testing Full Event Stream with EventEncoder
==================================================
üì§ Request: Thread=encoder-test-8549dd92, Run=run-1762168708
üîó Connection: 200
üìß Response Content-Type: text/event-stream; charset=utf-8
üîß Encoder Header: enabled
üöÄ RUN_STARTED: None
üìä STATE_SNAPSHOT: state updated
   üì® MESSAGES_SNAPSHOT
   üîÑ STEP_STARTED: None
   üì® STEP_FINISHED
   üîÑ STEP_STARTED: None
üí¨ TEXT_MESSAGE_START:    üì® STATE_DELTA
   üì® RUN_ERROR
   üì® CUSTOM

üìà Event Stream Complete:
   Total events processed: 10

üéõÔ∏è Testing Different Encodings
==================================================

üîß Testing Accept: text/event-stream
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168712506,"threadId":"encoding-test-e57b","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168712506,"snapshot":{"thread_id":"encoding-test-e57b...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168712506,"messages":[{"id":"msg-1762168711","role...

üîß Testing Accept: application/json
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168713896,"threadId":"encoding-test-32ff","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168713896,"snapshot":{"thread_id":"encoding-test-32ff...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168713896,"messages":[{"id":"msg-1762168712","role...

üîß Testing Accept: application/x-ndjson
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168715146,"threadId":"encoding-test-c0be","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168715146,"snapshot":{"thread_id":"encoding-test-c0be...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168715146,"messages":[{"id":"msg-1762168713","role...

üîß Testing Accept: */*
   üìß Response Content-Type: text/event-stream; charset=utf-8
   üîó Status: 200
   üìù Sample: data: {"type":"RUN_STARTED","timestamp":1762168716475,"threadId":"encoding-test-ba46","runId":"run-1...
   üìù Sample: data: {"type":"STATE_SNAPSHOT","timestamp":1762168716475,"snapshot":{"thread_id":"encoding-test-ba46...
   üìù Sample: data: {"type":"MESSAGES_SNAPSHOT","timestamp":1762168716475,"messages":[{"id":"msg-1762168715","role...

üéâ EventEncoder Testing Complete!
The AG-UI server is now properly encoding events for HTTP streaming.
