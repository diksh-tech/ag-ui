import os
import logging
import json
from typing import Optional, Any, Dict
from datetime import datetime
from motor.motor_asyncio import AsyncIOMotorClient
from dotenv import load_dotenv
load_dotenv() 

from mcp.server.fastmcp import FastMCP

HOST = os.getenv("MCP_HOST", "127.0.0.1")
PORT = int(os.getenv("MCP_PORT", "8000"))
TRANSPORT = os.getenv("MCP_TRANSPORT", "streamable-http")

MONGODB_URL = os.getenv("MONGO_URI")
DATABASE_NAME = os.getenv("MONGO_DB")
COLLECTION_NAME = os.getenv("MONGO_COLLECTION")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("flightops.mcp.server")

mcp = FastMCP("FlightOps MCP Server")

_mongo_client: Optional[AsyncIOMotorClient] = None
_db = None
_col = None

async def get_mongodb_client():
    """Initialize and return the global Motor client, DB and collection."""
    global _mongo_client, _db, _col
    if _mongo_client is None:
        logger.info("Connecting to MongoDB: %s", MONGODB_URL)
        _mongo_client = AsyncIOMotorClient(MONGODB_URL)
        _db = _mongo_client[DATABASE_NAME]
        _col = _db[COLLECTION_NAME]
    return _mongo_client, _db, _col

def normalize_flight_number(flight_number: Any) -> Optional[int]:
    """Convert flight_number to int. MongoDB stores it as int."""
    if flight_number is None or flight_number == "":
        return None
    if isinstance(flight_number, int):
        return flight_number
    try:
        return int(str(flight_number).strip())
    except (ValueError, TypeError):
        logger.warning(f"Could not normalize flight_number: {flight_number}")
        return None

def validate_date(date_str: str) -> Optional[str]:
    """
    Validate date_of_origin string. Accepts common formats.
    Returns normalized ISO date string YYYY-MM-DD if valid, else None.
    """
    if not date_str or date_str == "":
        return None
    
    # Handle common date formats
    formats = [
        "%Y-%m-%d",      # 2024-06-23
        "%d-%m-%Y",      # 23-06-2024
        "%Y/%m/%d",      # 2024/06/23
        "%d/%m/%Y",      # 23/06/2024
        "%B %d, %Y",     # June 23, 2024
        "%d %B %Y",      # 23 June 2024
        "%b %d, %Y",     # Jun 23, 2024
        "%d %b %Y"       # 23 Jun 2024
    ]
    
    for fmt in formats:
        try:
            dt = datetime.strptime(date_str, fmt)
            return dt.strftime("%Y-%m-%d")
        except ValueError:
            continue
    
    logger.warning(f"Could not parse date: {date_str}")
    return None

def make_query(carrier: str, flight_number: Optional[int], date_of_origin: str) -> Dict:
    """
    Build MongoDB query matching the actual database schema.
    """
    query = {}
    
    # Add carrier if provided
    if carrier:
        query["flightLegState.carrier"] = carrier
    
    # Add flight number as integer (as stored in DB)
    if flight_number is not None:
        query["flightLegState.flightNumber"] = flight_number
    
    # Add date if provided
    if date_of_origin:
        query["flightLegState.dateOfOrigin"] = date_of_origin
    
    logger.info(f"Built query: {json.dumps(query)}")
    return query

def response_ok(data: Any) -> str:
    """Return JSON string for successful response."""
    return json.dumps({"ok": True, "data": data}, indent=2, default=str)

def response_error(msg: str, code: int = 400) -> str:
    """Return JSON string for error response."""
    return json.dumps({"ok": False, "error": {"message": msg, "code": code}}, indent=2)

async def _fetch_one_async(query: dict, projection: dict) -> str:
    """
    Consistent async DB fetch and error handling.
    Returns JSON string response.
    """
    try:
        _, _, col = await get_mongodb_client()
        logger.info(f"Executing query: {json.dumps(query)}")
        
        result = await col.find_one(query, projection)
        
        if not result:
            logger.warning(f"No document found for query: {json.dumps(query)}")
            return response_error("No matching document found.", code=404)
        
        # Remove _id and _class to keep output clean
        if "_id" in result:
            result.pop("_id")
        if "_class" in result:
            result.pop("_class")
        
        logger.info(f"Query successful")
        return response_ok(result)
    except Exception as exc:
        logger.exception("DB query failed")
        return response_error(f"DB query failed: {str(exc)}", code=500)

# --- MCP Tools ---

@mcp.tool()
async def health_check() -> str:
    """
    Simple health check for orchestrators and clients.
    Attempts a cheap DB ping.
    """
    try:
        _, _, col = await get_mongodb_client()
        doc = await col.find_one({}, {"_id": 1})
        return response_ok({"status": "ok", "db_connected": doc is not None})
    except Exception as e:
        logger.exception("Health check DB ping failed")
        return response_error("DB unreachable", code=503)

@mcp.tool()
async def get_flight_basic_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Fetch basic flight information including carrier, flight number, date, stations, times, and status.
    
    Args:
        carrier: Airline carrier code (e.g., "6E", "AI")
        flight_number: Flight number as string (e.g., "215")
        date_of_origin: Date in YYYY-MM-DD format (e.g., "2024-06-23")
    """
    logger.info(f"get_flight_basic_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    # Normalize inputs
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date_of_origin format. Expected YYYY-MM-DD or common date formats", 400)
    
    query = make_query(carrier, fn, dob)
    
    # Project basic flight information
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.suffix": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.seqNumber": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.startStationICAO": 1,
        "flightLegState.endStationICAO": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.flightStatus": 1,
        "flightLegState.operationalStatus": 1,
        "flightLegState.flightType": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_operation_times(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Return estimated and actual operation times for a flight including takeoff, landing, block times.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_operation_times: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date format.", 400)
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.operation.estimatedTimes": 1,
        "flightLegState.operation.actualTimes": 1,
        "flightLegState.taxiOutTime": 1,
        "flightLegState.taxiInTime": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_equipment_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get aircraft equipment details including aircraft type, registration (tail number), and configuration.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_equipment_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.equipment.plannedAircraftType": 1,
        "flightLegState.equipment.aircraft": 1,
        "flightLegState.equipment.aircraftConfiguration": 1,
        "flightLegState.equipment.aircraftRegistration": 1,
        "flightLegState.equipment.assignedAircraftTypeIATA": 1,
        "flightLegState.equipment.assignedAircraftTypeICAO": 1,
        "flightLegState.equipment.assignedAircraftTypeIndigo": 1,
        "flightLegState.equipment.assignedAircraftConfiguration": 1,
        "flightLegState.equipment.tailLock": 1,
        "flightLegState.equipment.onwardFlight": 1,
        "flightLegState.equipment.actualOnwardFlight": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_delay_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Summarize delay reasons, durations, and total delay time for a specific flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_delay_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.operation.actualTimes.offBlock": 1,
        "flightLegState.delays": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_fuel_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Retrieve fuel summary including planned vs actual fuel for takeoff, landing, and total consumption.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_fuel_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.operation.fuel": 1,
        "flightLegState.operation.flightPlan.offBlockFuel": 1,
        "flightLegState.operation.flightPlan.takeoffFuel": 1,
        "flightLegState.operation.flightPlan.landingFuel": 1,
        "flightLegState.operation.flightPlan.holdFuel": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_passenger_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get passenger count and connection information for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_passenger_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.pax": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_crew_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get crew connections and details for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_crew_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.crewConnections": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def raw_mongodb_query(query_json: str, limit: int = 10) -> str:
    """
    Execute a raw MongoDB query (stringified JSON) generated by the LLM or user.

    Supports only read/find operations ‚Äî no write, delete, or aggregation commands.
    Automatically cleans and validates the input for safety.
    """

    def _safe_json_loads(text: str) -> dict:
        """Convert query string to JSON safely (handles single quotes and minor LLM mistakes)."""
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            try:
                fixed = text.replace("'", '"')
                return json.loads(fixed)
            except Exception as e:
                raise ValueError(f"Invalid JSON query: {e}")

    try:
        _, _, col = await get_mongodb_client()

        try:
            query = _safe_json_loads(query_json)
        except ValueError as e:
            return response_error(f"‚ùå Invalid JSON query. {str(e)}", 400)

        if not isinstance(query, dict):
            return response_error("‚ùå Query must be a JSON object.", 400)

        forbidden_ops = ["$where", "$out", "$merge", "$accumulator", "$function"]
        for key in query.keys():
            if key in forbidden_ops or key.startswith("$"):
                return response_error(f"‚ùå Operator '{key}' is not allowed.", 400)

        limit = min(max(1, int(limit)), 50)

        logger.info(f"Executing safe MongoDB query: {query} | limit={limit}")

        cursor = col.find(query).sort("flightLegState.dateOfOrigin", -1).limit(limit)
        docs = []
        async for doc in cursor:
            doc.pop("_id", None)
            doc.pop("_class", None)
            docs.append(doc)

        if not docs:
            return response_error("No documents found for the given query.", 404)

        return response_ok({"count": len(docs), "documents": docs})

    except Exception as exc:
        logger.exception("‚ùå raw_mongodb_query failed")
        return response_error(f"Raw MongoDB query failed: {str(exc)}", 500)


# --- Run MCP Server ---
if __name__ == "__main__":
    logger.info("Starting FlightOps MCP Server on %s:%s (transport=%s)", HOST, PORT, TRANSPORT)
    logger.info("MongoDB URL: %s, Database: %s, Collection: %s", MONGODB_URL, DATABASE_NAME, COLLECTION_NAME)
    mcp.run(transport="streamable-http")
#################################################################################################
import os
import json
import logging
import asyncio
from typing import List, Dict, Any
from dotenv import load_dotenv
from openai import AzureOpenAI
from mcp import ClientSession
from mcp.client.stdio import stdio_client
from mcp.client.streamable_http import streamablehttp_client

from tool_registry import TOOLS

# Load environment variables
load_dotenv()

MCP_SERVER_URL = os.getenv("MCP_SERVER_URL", "http://127.0.0.1:8000")

# Azure OpenAI configuration
AZURE_OPENAI_KEY = os.getenv("AZURE_OPENAI_KEY")
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4o")
AZURE_API_VERSION = os.getenv("AZURE_API_VERSION", "2024-12-01-preview")

if not AZURE_OPENAI_KEY:
    raise RuntimeError("‚ùå AZURE_OPENAI_KEY not set in environment")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("FlightOps.MCPClient")

# Initialize Azure OpenAI client
client_azure = AzureOpenAI(
    api_key=AZURE_OPENAI_KEY,
    api_version=AZURE_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)

# SYSTEM PROMPTS
def _build_tool_prompt() -> str:
    """Convert TOOLS dict into compact text to feed the LLM."""
    lines = []
    for name, meta in TOOLS.items():
        arg_str = ", ".join(meta["args"])
        lines.append(f"- {name}({arg_str}): {meta['desc']}")
    return "\n".join(lines)

SYSTEM_PROMPT_PLAN = f"""
You are an assistant that converts user questions into MCP tool calls.

Available tools:
{_build_tool_prompt()}

Rules:
1. Output only valid JSON.
2. Always return a top-level key 'plan' as a list.
3. Use the most appropriate tool for the query.
4. Do not invent tool names.
"""

SYSTEM_PROMPT_SUMMARIZE = """
You are an assistant that summarizes tool outputs into a concise, readable answer.
Be factual, short, and helpful.
"""

class FlightOpsMCPClient:
    def __init__(self, base_url: str = None):
        self.base_url = base_url or MCP_SERVER_URL
        self.session: ClientSession = None
        self._client_context = None

    async def connect(self):
        """Connect to MCP server"""
        try:
            logger.info(f"üîó Connecting to MCP server at {self.base_url}")
            
            # Use streamable HTTP client for FastMCP
            self._client_context = streamablehttp_client(self.base_url)
            read_stream, write_stream, _ = await self._client_context.__aenter__()
            
            self.session = ClientSession(read_stream, write_stream)
            await self.session.__aenter__()
            await self.session.initialize()
            
            logger.info("‚úÖ Connected to MCP server successfully")
            
            # Test the connection by listing tools
            tools = await self.list_tools()
            logger.info(f"üîß Available tools: {len(tools.get('tools', {}))}")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to MCP server: {e}")
            raise

    async def disconnect(self):
        """Disconnect from MCP server"""
        try:
            if self.session:
                await self.session.__aexit__(None, None, None)
            if self._client_context:
                await self._client_context.__aexit__(None, None, None)
            logger.info("üîå Disconnected from MCP server")
        except Exception as e:
            logger.error(f"Error during disconnect: {e}")

    def _call_azure_openai(self, messages: list, temperature: float = 0.1, max_tokens: int = 2048) -> str:
        """Call Azure OpenAI API"""
        try:
            completion = client_azure.chat.completions.create(
                model=AZURE_OPENAI_DEPLOYMENT,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
            )
            return completion.choices[0].message.content
        except Exception as e:
            logger.error(f"‚ùå Azure OpenAI API error: {e}")
            return json.dumps({"error": str(e)})

    async def list_tools(self) -> dict:
        """List available MCP tools"""
        try:
            if not self.session:
                await self.connect()
                
            tools_list = await self.session.list_tools()
            tools_dict = {
                tool.name: {
                    "description": tool.description,
                    "inputSchema": tool.inputSchema
                } for tool in tools_list.tools
            }
            return {"tools": tools_dict}
        except Exception as e:
            logger.error(f"‚ùå Error listing tools: {e}")
            return {"error": str(e)}

    async def invoke_tool(self, tool_name: str, args: dict) -> dict:
        """Invoke a specific MCP tool"""
        try:
            if not self.session:
                await self.connect()
                
            logger.info(f"üîß Calling tool: {tool_name} with args: {args}")
            result = await self.session.call_tool(tool_name, args)

            if result.content:
                content_items = []
                for item in result.content:
                    if hasattr(item, 'text'):
                        try:
                            content_items.append(json.loads(item.text))
                        except json.JSONDecodeError:
                            content_items.append(item.text)
                
                if len(content_items) == 1:
                    return content_items[0]
                return {"results": content_items}

            return {"error": "No content in response"}
        except Exception as e:
            logger.error(f"‚ùå Error invoking tool {tool_name}: {e}")
            return {"error": str(e)}

    def plan_tools(self, user_query: str) -> dict:
        """Plan which tools to call for a user query"""
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_PLAN},
            {"role": "user", "content": user_query},
        ]

        content = self._call_azure_openai(messages, temperature=0.1)
        if not content:
            logger.warning("‚ö†Ô∏è LLM returned empty response")
            return {"plan": []}

        # Clean the response
        cleaned = content.strip()
        if cleaned.startswith("```"):
            cleaned = cleaned.strip("`")
            if cleaned.lower().startswith("json"):
                cleaned = cleaned[4:].strip()
            cleaned = cleaned.replace("```", "").strip()

        try:
            plan = json.loads(cleaned)
            if isinstance(plan, dict) and "plan" in plan:
                return plan
            else:
                logger.warning("‚ö†Ô∏è LLM output did not contain 'plan' key")
                return {"plan": []}
        except json.JSONDecodeError:
            logger.warning(f"‚ùå Could not parse LLM plan: {cleaned}")
            return {"plan": []}

    def summarize_results(self, user_query: str, plan: list, results: list) -> dict:
        """Summarize the tool execution results"""
        # Convert all results to strings for safe processing
        safe_results = []
        for result in results:
            if isinstance(result, dict):
                safe_results.append(json.dumps(result, default=str))
            else:
                safe_results.append(str(result))

        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_SUMMARIZE},
            {"role": "user", "content": f"Question: {user_query}"},
            {"role": "assistant", "content": f"Plan: {json.dumps(plan, indent=2)}"},
            {"role": "assistant", "content": f"Results: {json.dumps(safe_results, indent=2)}"},
        ]
        summary = self._call_azure_openai(messages, temperature=0.3)
        return {"summary": summary}

    async def run_query(self, user_query: str) -> dict:
        """Main method to run a user query through MCP tools"""
        try:
            logger.info(f"üë§ User query: {user_query}")
            
            # Plan which tools to use
            plan_data = self.plan_tools(user_query)
            plan = plan_data.get("plan", [])
            
            if not plan:
                return {"error": "LLM did not produce a valid tool plan."}

            results = []
            for step in plan:
                tool = step.get("tool")
                args = step.get("arguments", {})

                # Clean up bad args
                args = {k: v for k, v in args.items() if v and str(v).strip().lower() != "unknown"}

                # Execute the tool
                resp = await self.invoke_tool(tool, args)
                results.append({tool: resp})

            # Summarize results
            summary = self.summarize_results(user_query, plan, results)
            
            return {
                "plan": plan, 
                "results": results, 
                "summary": summary,
                "status": "success"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error in run_query: {e}")
            return {"error": str(e), "status": "error"}
#########################################################################################
import os
import uuid
import json
import asyncio
from typing import List, Any, AsyncGenerator
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv

load_dotenv()

app = FastAPI(title="FlightOps AG-UI Working Server")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Import after environment is loaded
try:
    from ag_ui.core import RunAgentInput, UserMessage
    from ag_ui.encoder import EventEncoder
    AGUI_AVAILABLE = True
except ImportError:
    AGUI_AVAILABLE = False
    print("‚ö†Ô∏è AG-UI not installed, using fallback")

from mcp_client import FlightOpsMCPClient
from tool_registry import TOOLS

class WorkingFlightOpsAgent:
    def __init__(self):
        self.mcp_client = FlightOpsMCPClient()
        self.connected = False

    async def ensure_connected(self):
        """Ensure MCP client is connected"""
        if not self.connected:
            await self.mcp_client.connect()
            self.connected = True

    async def process_query(self, user_message: str):
        """Process user query and return results"""
        await self.ensure_connected()
        return await self.mcp_client.run_query(user_message)

# Global agent instance
agent = WorkingFlightOpsAgent()

@app.post("/agent")
async def agent_endpoint(request: Request):
    """Main AG-UI agent endpoint"""
    try:
        # Parse request
        body = await request.json()
        
        # Extract user message
        messages = body.get("messages", [])
        user_message = None
        
        for msg in messages:
            if msg.get("role") == "user":
                user_message = msg.get("content", "")
                break
        
        if not user_message:
            raise HTTPException(status_code=400, detail="No user message found")

        print(f"üì• Processing query: {user_message}")

        # Process the query
        result = await agent.process_query(user_message)
        
        # Extract response text safely
        if isinstance(result, dict):
            if "summary" in result and isinstance(result["summary"], dict):
                response_text = result["summary"].get("summary", "No summary available")
            elif "summary" in result:
                response_text = result["summary"]
            elif "error" in result:
                response_text = f"Error: {result['error']}"
            else:
                response_text = json.dumps(result, indent=2)
        else:
            response_text = str(result)

        # Ensure response_text is a string
        if not isinstance(response_text, str):
            response_text = str(response_text)

        # Initialize encoder
        encoder = EventEncoder(accept="text/event-stream") if AGUI_AVAILABLE else None

        async def generate_events():
            """Generate AG-UI events"""
            try:
                # Start event
                if AGUI_AVAILABLE:
                    from ag_ui.core import RunStartedEvent, RunFinishedEvent, RunErrorEvent
                    from ag_ui.core import TextMessageStartEvent, TextMessageContentEvent, TextMessageEndEvent
                    from ag_ui.core import EventType
                    
                    # Emit run started
                    yield encoder.encode(RunStartedEvent(
                        type=EventType.RUN_STARTED,
                        thread_id=body.get("thread_id", "default"),
                        run_id=body.get("run_id", f"run-{uuid.uuid4().hex[:8]}")
                    ))

                    # Emit text message start
                    message_id = f"msg-{uuid.uuid4().hex[:8]}"
                    yield encoder.encode(TextMessageStartEvent(
                        type=EventType.TEXT_MESSAGE_START,
                        message_id=message_id,
                        role="assistant"
                    ))

                # Stream response - FIXED: Don't split if it's not a string or if it's empty
                if response_text and isinstance(response_text, str):
                    # Split into words for streaming
                    words = response_text.split()
                    for word in words:
                        if AGUI_AVAILABLE:
                            yield encoder.encode(TextMessageContentEvent(
                                type=EventType.TEXT_MESSAGE_CONTENT,
                                message_id=message_id,
                                delta=word + " "
                            ))
                        else:
                            yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'delta': word + ' '})}\n\n"
                        
                        await asyncio.sleep(0.05)
                else:
                    # Send empty response if no content
                    if AGUI_AVAILABLE:
                        yield encoder.encode(TextMessageContentEvent(
                            type=EventType.TEXT_MESSAGE_CONTENT,
                            message_id=message_id,
                            delta="No response generated."
                        ))
                    else:
                        yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'delta': 'No response generated.'})}\n\n"

                # End events
                if AGUI_AVAILABLE:
                    yield encoder.encode(TextMessageEndEvent(
                        type=EventType.TEXT_MESSAGE_END,
                        message_id=message_id
                    ))
                    
                    yield encoder.encode(RunFinishedEvent(
                        type=EventType.RUN_FINISHED,
                        thread_id=body.get("thread_id", "default"),
                        run_id=body.get("run_id", f"run-{uuid.uuid4().hex[:8]}")
                    ))

            except Exception as error:
                print(f"‚ùå Error in event generation: {error}")
                if AGUI_AVAILABLE:
                    yield encoder.encode(RunErrorEvent(
                        type=EventType.RUN_ERROR,
                        message=str(error)
                    ))
                else:
                    yield f"data: {json.dumps({'type': 'RUN_ERROR', 'message': str(error)})}\n\n"

        return StreamingResponse(
            generate_events(),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Access-Control-Allow-Origin": "*",
            }
        )

    except Exception as e:
        print(f"‚ùå Server error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/")
async def root():
    return {"status": "healthy", "service": "FlightOps AG-UI Server"}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        await agent.ensure_connected()
        tools = await agent.mcp_client.list_tools()
        return {
            "status": "healthy",
            "mcp_connected": True,
            "tools_available": len(tools.get("tools", {})),
            "ag_ui_available": AGUI_AVAILABLE
        }
    except Exception as e:
        return {
            "status": "unhealthy", 
            "mcp_connected": False,
            "error": str(e),
            "ag_ui_available": AGUI_AVAILABLE
        }

@app.get("/tools")
async def list_tools():
    """List available MCP tools"""
    try:
        await agent.ensure_connected()
        return await agent.mcp_client.list_tools()
    except Exception as e:
        return {"error": str(e)}

@app.post("/query")
async def direct_query(request: Request):
    """Direct query endpoint for testing"""
    body = await request.json()
    user_query = body.get("query", "")
    
    try:
        result = await agent.process_query(user_query)
        return result
    except Exception as e:
        return {"error": str(e)}

if __name__ == "__main__":
    import uvicorn
    print("üöÄ Starting FlightOps AG-UI Working Server...")
    uvicorn.run(app, host="0.0.0.0", port=8001, log_level="info")
#################################################################################
import asyncio
import httpx
import json

async def test_health():
    """Test server health"""
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get("http://localhost:8001/health")
            print(f"üè• Health Check: {response.status_code}")
            print(json.dumps(response.json(), indent=2))
        except Exception as e:
            print(f"‚ùå Health check failed: {e}")

async def test_tools():
    """Test tools endpoint"""
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get("http://localhost:8001/tools")
            print(f"üîß Tools Check: {response.status_code}")
            data = response.json()
            if "tools" in data:
                print(f"‚úÖ Available tools: {len(data['tools'])}")
                for tool_name in data["tools"].keys():
                    print(f"   - {tool_name}")
            else:
                print(f"‚ùå No tools: {data}")
        except Exception as e:
            print(f"‚ùå Tools check failed: {e}")

async def test_direct_query():
    """Test direct query"""
    async with httpx.AsyncClient() as client:
        try:
            test_queries = [
                "health check",
                "What's the status of flight 6E 215?",
                "Get flight basic info for 6E 215"
            ]
            
            for query in test_queries:
                print(f"\nüîç Testing: {query}")
                response = await client.post(
                    "http://localhost:8001/query",
                    json={"query": query}
                )
                print(f"üìä Response: {response.status_code}")
                result = response.json()
                
                # Safe handling of response
                if isinstance(result, dict):
                    if "summary" in result:
                        summary = result["summary"]
                        if isinstance(summary, dict):
                            # Handle nested summary structure
                            summary_text = summary.get("summary", str(summary))
                        else:
                            summary_text = str(summary)
                        print(f"‚úÖ Summary: {summary_text[:100]}..." if len(summary_text) > 100 else f"‚úÖ Summary: {summary_text}")
                    elif "error" in result:
                        print(f"‚ùå Error: {result['error']}")
                    else:
                        print(f"üì¶ Result: {json.dumps(result, indent=2)[:200]}...")
                else:
                    print(f"üì¶ Raw Result: {str(result)[:100]}...")
                    
        except Exception as e:
            print(f"‚ùå Direct query failed: {str(e)}")

async def test_agui_agent():
    """Test AG-UI agent endpoint"""
    async with httpx.AsyncClient(timeout=30.0) as client:
        try:
            test_input = {
                "thread_id": "test-thread",
                "run_id": "test-run-001",
                "messages": [
                    {
                        "id": "msg-1",
                        "role": "user",
                        "content": "What's the status of flight 6E 215?"
                    }
                ],
                "tools": []
            }
            
            print(f"\nüéØ Testing AG-UI Agent...")
            async with client.stream(
                "POST",
                "http://localhost:8001/agent",
                json=test_input,
                headers={"Accept": "text/event-stream"}
            ) as response:
                
                print(f"üîó Status: {response.status_code}")
                
                async for line in response.aiter_lines():
                    if line.startswith('data: '):
                        try:
                            event_data = line[6:]  # Remove 'data: ' prefix
                            event = json.loads(event_data)
                            event_type = event.get('type', 'UNKNOWN')
                            
                            if event_type == 'TEXT_MESSAGE_CONTENT':
                                delta = event.get('delta', '')
                                if isinstance(delta, str):
                                    print(delta, end='', flush=True)
                                else:
                                    print(str(delta), end='', flush=True)
                            elif event_type == 'RUN_STARTED':
                                print("üöÄ Run started...")
                            elif event_type == 'RUN_FINISHED':
                                print("\n‚úÖ Run completed!")
                            elif event_type == 'RUN_ERROR':
                                print(f"\n‚ùå Error: {event.get('message')}")
                                
                        except json.JSONDecodeError:
                            continue
                        except Exception as e:
                            print(f"\n‚ùå Event processing error: {e}")
                            continue
                            
        except Exception as e:
            print(f"‚ùå AG-UI agent test failed: {str(e)}")

async def main():
    print("üî¨ FLIGHTOPS SYSTEM TEST SUITE")
    print("=" * 50)
    
    # 1. Test health
    await test_health()
    
    # 2. Test tools
    await test_tools()
    
    # 3. Test direct query
    await test_direct_query()
    
    # 4. Test AG-UI agent
    await test_agui_agent()
    
    print("\nüéâ TESTING COMPLETE!")

if __name__ == "__main__":
    asyncio.run(main())
##########################################################################
TOOLS = {
    "get_flight_basic_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Fetch basic flight information including carrier, flight number, stations, scheduled times, and flight status.",
    },
    "get_equipment_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get aircraft equipment details: aircraft type, tail number (registration), and configuration.",
    },
    "get_operation_times": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Return estimated and actual operation times: takeoff, landing, departure, arrival, and block times.",
    },
    "get_fuel_summary": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Retrieve fuel summary including planned vs actual fuel consumption for the flight.",
    },
    "get_delay_summary": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get delay information including delay reasons, durations, and total delay time.",
    },
    "get_passenger_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get passenger count and connection information for the flight.",
    },
    "get_crew_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get crew connections and details for the flight.",
    },
    "health_check": {
        "args": [],
        "desc": "Check the health status of the MCP server and database connection.",
    },
    "raw_mongodb_query": {
        "args": ["query_json", "limit"],
        "desc": "Run a raw MongoDB query (JSON format) for complex queries.",
    },
}
########################################################################################
import os
import uuid
import json
import asyncio
from typing import Dict, Any, AsyncGenerator, List, Optional
from datetime import datetime

from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse

# AG-UI imports
try:
    from ag_ui.encoder import EventEncoder
    from ag_ui.core import (
        RunAgentInput, RunStartedEvent, RunFinishedEvent, RunErrorEvent,
        TextMessageStartEvent, TextMessageContentEvent, TextMessageEndEvent,
        ToolCallStartEvent, ToolCallArgsEvent, ToolCallEndEvent,
        StateSnapshotEvent, EventType, BaseEvent
    )
    AGUI_AVAILABLE = True
except ImportError:
    AGUI_AVAILABLE = False
    print("‚ö†Ô∏è AG-UI not installed, using fallback events")

# Your existing imports
from mcp_client import FlightOpsMCPClient
from tool_registry import TOOLS

app = FastAPI(
    title="FlightOps AG-UI Middleware",
    description="Middleware that bridges FlightOps MCP system to AG-UI protocol",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class FlightOpsAGUIMiddleware:
    """
    Middleware that translates between FlightOps MCP system and AG-UI protocol.
    This enables any AG-UI compatible client to use your FlightOps system.
    """
    
    def __init__(self):
        self.mcp_client = FlightOpsMCPClient()
        self.connected = False
        self.encoder = EventEncoder() if AGUI_AVAILABLE else None
        
    async def ensure_connected(self):
        """Ensure connection to MCP server"""
        if not self.connected:
            await self.mcp_client.connect()
            self.connected = True
    
    def translate_mcp_tools_to_agui(self, tools_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Translate MCP tools format to AG-UI tools format"""
        agui_tools = []
        
        for tool_name, tool_info in tools_data.get("tools", {}).items():
            agui_tool = {
                "name": tool_name,
                "description": tool_info.get("description", ""),
                "parameters": tool_info.get("inputSchema", {})
            }
            agui_tools.append(agui_tool)
        
        return agui_tools
    
    async def process_with_agui_events(self, user_input: str, thread_id: str = None, run_id: str = None) -> AsyncGenerator[str, None]:
        """
        Core middleware function that processes user input and emits AG-UI events.
        This bridges your MCP system to the AG-UI protocol.
        """
        thread_id = thread_id or f"thread_{uuid.uuid4().hex[:8]}"
        run_id = run_id or f"run_{uuid.uuid4().hex[:8]}"
        
        try:
            await self.ensure_connected()
            
            # 1. Start AG-UI run
            if AGUI_AVAILABLE:
                yield self.encoder.encode(RunStartedEvent(
                    type=EventType.RUN_STARTED,
                    thread_id=thread_id,
                    run_id=run_id
                ))
            else:
                yield f"data: {json.dumps({'type': 'RUN_STARTED', 'thread_id': thread_id, 'run_id': run_id})}\n\n"
            
            # 2. Start text message
            message_id = f"msg_{uuid.uuid4().hex[:8]}"
            if AGUI_AVAILABLE:
                yield self.encoder.encode(TextMessageStartEvent(
                    type=EventType.TEXT_MESSAGE_START,
                    message_id=message_id,
                    role="assistant"
                ))
            else:
                yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_START', 'message_id': message_id, 'role': 'assistant'})}\n\n"
            
            # 3. Show initial processing message
            initial_message = "üîç Analyzing your flight operations query...\n\n"
            if AGUI_AVAILABLE:
                yield self.encoder.encode(TextMessageContentEvent(
                    type=EventType.TEXT_MESSAGE_CONTENT,
                    message_id=message_id,
                    delta=initial_message
                ))
            else:
                yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': initial_message})}\n\n"
            
            # 4. Plan tools using existing MCP client
            plan_data = self.mcp_client.plan_tools(user_input)
            plan = plan_data.get("plan", [])
            
            if not plan:
                no_tools_msg = "‚ùå I couldn't find relevant flight operations tools for your query.\n"
                if AGUI_AVAILABLE:
                    yield self.encoder.encode(TextMessageContentEvent(
                        type=EventType.TEXT_MESSAGE_CONTENT,
                        message_id=message_id,
                        delta=no_tools_msg
                    ))
                else:
                    yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': no_tools_msg})}\n\n"
            else:
                # 5. Execute each tool with AG-UI events
                execution_results = []
                
                for step_index, step in enumerate(plan):
                    tool_name = step.get("tool")
                    tool_args = step.get("arguments", {})
                    
                    # Clean arguments
                    tool_args = {k: v for k, v in tool_args.items() 
                               if v and str(v).strip().lower() != "unknown"}
                    
                    # AG-UI Tool Call Start
                    tool_call_id = f"tool_{step_index}_{uuid.uuid4().hex[:8]}"
                    if AGUI_AVAILABLE:
                        yield self.encoder.encode(ToolCallStartEvent(
                            type=EventType.TOOL_CALL_START,
                            tool_call_id=tool_call_id,
                            tool_name=tool_name,
                            role="assistant"
                        ))
                    else:
                        yield f"data: {json.dumps({'type': 'TOOL_CALL_START', 'tool_call_id': tool_call_id, 'tool_name': tool_name, 'role': 'assistant'})}\n\n"
                    
                    # AG-UI Tool Call Arguments
                    if AGUI_AVAILABLE:
                        yield self.encoder.encode(ToolCallArgsEvent(
                            type=EventType.TOOL_CALL_ARGS,
                            tool_call_id=tool_call_id,
                            args=tool_args
                        ))
                    else:
                        yield f"data: {json.dumps({'type': 'TOOL_CALL_ARGS', 'tool_call_id': tool_call_id, 'args': tool_args})}\n\n"
                    
                    # Show execution in text stream
                    executing_msg = f"üõ†Ô∏è Executing {tool_name}... "
                    if AGUI_AVAILABLE:
                        yield self.encoder.encode(TextMessageContentEvent(
                            type=EventType.TEXT_MESSAGE_CONTENT,
                            message_id=message_id,
                            delta=executing_msg
                        ))
                    else:
                        yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': executing_msg})}\n\n"
                    
                    try:
                        # Execute via existing MCP client
                        tool_result = await self.mcp_client.invoke_tool(tool_name, tool_args)
                        execution_results.append({tool_name: tool_result})
                        
                        # AG-UI Tool Call End with result
                        if AGUI_AVAILABLE:
                            yield self.encoder.encode(ToolCallEndEvent(
                                type=EventType.TOOL_CALL_END,
                                tool_call_id=tool_call_id,
                                result=tool_result
                            ))
                        else:
                            yield f"data: {json.dumps({'type': 'TOOL_CALL_END', 'tool_call_id': tool_call_id, 'result': tool_result})}\n\n"
                        
                        done_msg = "‚úÖ Done\n"
                        if AGUI_AVAILABLE:
                            yield self.encoder.encode(TextMessageContentEvent(
                                type=EventType.TEXT_MESSAGE_CONTENT,
                                message_id=message_id,
                                delta=done_msg
                            ))
                        else:
                            yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': done_msg})}\n\n"
                        
                    except Exception as tool_error:
                        error_msg = f"‚ùå Failed: {str(tool_error)}\n"
                        if AGUI_AVAILABLE:
                            yield self.encoder.encode(TextMessageContentEvent(
                                type=EventType.TEXT_MESSAGE_CONTENT,
                                message_id=message_id,
                                delta=error_msg
                            ))
                        else:
                            yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': error_msg})}\n\n"
                
                # 6. Generate summary using existing MCP summarization
                summary_msg = "\nüìà Generating flight operations summary...\n\n"
                if AGUI_AVAILABLE:
                    yield self.encoder.encode(TextMessageContentEvent(
                        type=EventType.TEXT_MESSAGE_CONTENT,
                        message_id=message_id,
                        delta=summary_msg
                    ))
                else:
                    yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': summary_msg})}\n\n"
                
                summary_data = self.mcp_client.summarize_results(user_input, plan, execution_results)
                summary_text = summary_data.get("summary", {}).get("summary", "Summary completed.")
                
                # Stream the summary word by word
                words = summary_text.split()
                for word in words:
                    if AGUI_AVAILABLE:
                        yield self.encoder.encode(TextMessageContentEvent(
                            type=EventType.TEXT_MESSAGE_CONTENT,
                            message_id=message_id,
                            delta=word + " "
                        ))
                    else:
                        yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': word + ' '})}\n\n"
                    await asyncio.sleep(0.03)
            
            # 7. End text message
            if AGUI_AVAILABLE:
                yield self.encoder.encode(TextMessageEndEvent(
                    type=EventType.TEXT_MESSAGE_END,
                    message_id=message_id
                ))
            else:
                yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_END', 'message_id': message_id})}\n\n"
            
            # 8. Final state snapshot
            if AGUI_AVAILABLE:
                yield self.encoder.encode(StateSnapshotEvent(
                    type=EventType.STATE_SNAPSHOT,
                    state={
                        "query_type": "flight_operations",
                        "tools_executed": [step.get("tool") for step in plan],
                        "execution_time": datetime.now().isoformat(),
                        "status": "success"
                    }
                ))
            else:
                yield f"data: {json.dumps({'type': 'STATE_SNAPSHOT', 'state': {'query_type': 'flight_operations', 'tools_executed': [step.get('tool') for step in plan], 'status': 'success'}})}\n\n"
            
            # 9. Run finished
            if AGUI_AVAILABLE:
                yield self.encoder.encode(RunFinishedEvent(
                    type=EventType.RUN_FINISHED,
                    thread_id=thread_id,
                    run_id=run_id
                ))
            else:
                yield f"data: {json.dumps({'type': 'RUN_FINISHED', 'thread_id': thread_id, 'run_id': run_id})}\n\n"
            
        except Exception as e:
            # Error handling
            error_msg = f"\nüö® Middleware Error: {str(e)}\n"
            if AGUI_AVAILABLE:
                yield self.encoder.encode(TextMessageContentEvent(
                    type=EventType.TEXT_MESSAGE_CONTENT,
                    message_id=message_id,
                    delta=error_msg
                ))
                
                yield self.encoder.encode(RunErrorEvent(
                    type=EventType.RUN_ERROR,
                    message=f"Middleware translation failed: {str(e)}"
                ))
            else:
                yield f"data: {json.dumps({'type': 'TEXT_MESSAGE_CONTENT', 'message_id': message_id, 'delta': error_msg})}\n\n"
                yield f"data: {json.dumps({'type': 'RUN_ERROR', 'message': f'Middleware translation failed: {str(e)}'})}\n\n"

# Global middleware instance
flightops_middleware = FlightOpsAGUIMiddleware()

@app.post("/ag-ui/agent")
async def ag_ui_agent_endpoint(request: Request):
    """
    AG-UI compliant agent endpoint that bridges MCP system to AG-UI protocol.
    This enables any AG-UI client to use your FlightOps system.
    """
    try:
        # Parse request
        body = await request.json()
        
        # Extract user message
        messages = body.get("messages", [])
        user_message = None
        
        for msg in messages:
            if msg.get("role") == "user":
                user_message = msg.get("content", "")
                break
        
        if not user_message:
            raise HTTPException(status_code=400, detail="No user message found")

        print(f"üîÑ AG-UI Middleware processing: '{user_message}'")
        
        # Generate AG-UI events from MCP execution
        return StreamingResponse(
            flightops_middleware.process_with_agui_events(
                user_message,
                body.get("thread_id"),
                body.get("run_id")
            ),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Middleware-Type": "FlightOps-MCP-to-AGUI",
                "Access-Control-Allow-Origin": "*"
            }
        )
        
    except Exception as e:
        print(f"‚ùå Middleware error: {e}")
        raise HTTPException(status_code=500, detail=f"Middleware error: {str(e)}")

@app.get("/ag-ui/health")
async def middleware_health():
    """AG-UI middleware health check"""
    try:
        await flightops_middleware.ensure_connected()
        tools = await flightops_middleware.mcp_client.list_tools()
        
        return {
            "status": "healthy",
            "middleware": "FlightOps MCP to AG-UI Bridge",
            "mcp_connected": True,
            "ag_ui_available": AGUI_AVAILABLE,
            "available_tools": len(tools.get("tools", {})),
            "translation_capabilities": [
                "MCP-tools-to-AGUI-events",
                "FlightOps-protocol-to-AGUI-protocol", 
                "Real-time-tool-execution",
                "Streaming-responses"
            ]
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e),
            "ag_ui_available": AGUI_AVAILABLE
        }

@app.get("/ag-ui/tools")
async def middleware_tools():
    """Get available tools in AG-UI format"""
    try:
        await flightops_middleware.ensure_connected()
        mcp_tools = await flightops_middleware.mcp_client.list_tools()
        agui_tools = flightops_middleware.translate_mcp_tools_to_agui(mcp_tools)
        
        return {
            "tools": agui_tools,
            "source": "flightops-mcp-server",
            "translated_by": "ag-ui-middleware",
            "count": len(agui_tools)
        }
    except Exception as e:
        return {"error": str(e)}

@app.get("/ag-ui/status")
async def middleware_status():
    """Get detailed middleware status"""
    try:
        await flightops_middleware.ensure_connected()
        mcp_tools = await flightops_middleware.mcp_client.list_tools()
        
        return {
            "middleware": {
                "status": "running",
                "version": "1.0.0",
                "translation_direction": "MCP ‚Üí AG-UI",
                "ag_ui_available": AGUI_AVAILABLE
            },
            "mcp_server": {
                "connected": True,
                "tools_available": len(mcp_tools.get("tools", {})),
                "tools_list": list(mcp_tools.get("tools", {}).keys())
            },
            "ag_ui": {
                "protocol_version": "1.0",
                "supported_events": [
                    "RUN_STARTED", "RUN_FINISHED", "RUN_ERROR",
                    "TEXT_MESSAGE_*", "TOOL_CALL_*", "STATE_SNAPSHOT"
                ]
            }
        }
    except Exception as e:
        return {
            "middleware": {"status": "error", "error": str(e)},
            "mcp_server": {"connected": False},
            "ag_ui": {"protocol_version": "1.0"}
        }

@app.get("/")
async def root():
    return {
        "message": "FlightOps AG-UI Middleware",
        "status": "running",
        "description": "Bridges FlightOps MCP system to AG-UI protocol"
    }

@app.post("/query")
async def direct_query(request: Request):
    """Direct query endpoint for backward compatibility"""
    body = await request.json()
    user_query = body.get("query", "")
    
    try:
        await flightops_middleware.ensure_connected()
        result = await flightops_middleware.mcp_client.run_query(user_query)
        return result
    except Exception as e:
        return {"error": str(e)}

if __name__ == "__main__":
    import uvicorn
    
    print("üåâ Starting FlightOps AG-UI Middleware Bridge...")
    print("================================================")
    print("üîó This middleware bridges:")
    print("   MCP Server (port 8000) ‚Üî AG-UI Protocol")
    print("üì° Endpoints:")
    print("   - AG-UI Agent: http://localhost:8004/ag-ui/agent")
    print("   - Health:      http://localhost:8004/ag-ui/health") 
    print("   - Tools:       http://localhost:8004/ag-ui/tools")
    print("   - Status:      http://localhost:8004/ag-ui/status")
    print("üéØ Use this with any AG-UI compatible client!")
    print(f"üîß AG-UI Available: {AGUI_AVAILABLE}")
    
    uvicorn.run(app, host="0.0.0.0", port=8004, log_level="info")
###############################################################################
vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8004',  // AG-UI Middleware
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, '')
      },
      '/ag-ui': {
        target: 'http://localhost:8004',  // AG-UI Middleware
        changeOrigin: true,
        secure: false
      }
    }
  }
})
###################################################################################
import subprocess
import time
import webbrowser
import sys
import os

def run_command(command, name):
    """Run a command in a subprocess"""
    print(f"üöÄ Starting {name}...")
    try:
        process = subprocess.Popen(command, shell=True)
        return process
    except Exception as e:
        print(f"‚ùå Failed to start {name}: {e}")
        return None

def main():
    print("üéØ Starting FlightOps Full Stack System")
    print("=======================================")
    
    processes = []
    
    # Start MCP Server (port 8000)
    processes.append(run_command("python server.py", "MCP Server"))
    time.sleep(5)
    
    # Start AG-UI Middleware (port 8004) 
    processes.append(run_command("python ag_ui_middleware.py", "AG-UI Middleware"))
    time.sleep(5)
    
    print("\n‚úÖ All backend services started!")
    print("üìä Services Status:")
    print("   - MCP Server:        http://localhost:8000")
    print("   - AG-UI Middleware:  http://localhost:8004")
    print("   - React Frontend:    http://localhost:3000")
    print("\nüîó Your React frontend will connect to the AG-UI Middleware")
    print("üéØ You can now start the React frontend with: npm run dev")
    
    # Offer to open the browser
    response = input("\nüåê Open React frontend in browser? (y/n): ")
    if response.lower() == 'y':
        webbrowser.open('http://localhost:3000')
    
    try:
        # Keep the script running
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nüõë Shutting down all services...")
        for i, process in enumerate(processes):
            if process:
                print(f"   Stopping service {i+1}...")
                process.terminate()
        print("‚úÖ All services stopped!")

if __name__ == "__main__":
    main()
#####################################################################################################33
import React, { useState, useRef, useEffect } from 'react';
import { Send, Plane, Clock, User, Wifi, AlertTriangle, Menu, X, Tool } from 'lucide-react';
import './App.css';

// Import Indigo logo
import indigoLogo from './assets/indigo-logo.png';

// AG-UI Client for handling event streams
class AGUIClient {
  constructor(baseURL = 'http://localhost:8004') {
    this.baseURL = baseURL;
  }

  async *sendMessage(userInput, threadId = null, runId = null) {
    const response = await fetch(`${this.baseURL}/ag-ui/agent`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: [{ role: 'user', content: userInput }],
        thread_id: threadId,
        run_id: runId,
        tools: []
      }),
    });

    if (!response.ok) {
      throw new Error(`AG-UI error: ${response.status}`);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const event = JSON.parse(line.slice(6));
              yield event;
            } catch (e) {
              console.error('Error parsing AG-UI event:', e);
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  async getHealth() {
    const response = await fetch(`${this.baseURL}/ag-ui/health`);
    return response.json();
  }
}

function App() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [currentThreadId, setCurrentThreadId] = useState(null);
  const messagesEndRef = useRef(null);

  const aguiClient = new AGUIClient();

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Check server health on component mount
  useEffect(() => {
    checkHealth();
  }, []);

  const checkHealth = async () => {
    try {
      setConnectionStatus('connecting');
      const health = await aguiClient.getHealth();
      if (health.status === 'healthy') {
        setConnectionStatus('connected');
      } else {
        setConnectionStatus('error');
      }
    } catch (error) {
      setConnectionStatus('error');
    }
  };

  // AG-UI Event Handler
  const handleAGUIEvent = (event) => {
    switch (event.type) {
      case 'RUN_STARTED':
        setCurrentThreadId(event.thread_id);
        console.log('AG-UI Run started:', event.run_id);
        break;

      case 'TEXT_MESSAGE_START':
        setMessages(prev => [...prev, {
          id: event.message_id,
          type: 'assistant',
          content: '',
          timestamp: new Date().toLocaleTimeString(),
          isStreaming: true
        }]);
        break;

      case 'TEXT_MESSAGE_CONTENT':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.message_id) {
            return { ...msg, content: msg.content + (event.delta || '') };
          }
          return msg;
        }));
        break;

      case 'TEXT_MESSAGE_END':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.message_id) {
            return { ...msg, isStreaming: false };
          }
          return msg;
        }));
        break;

      case 'TOOL_CALL_START':
        setMessages(prev => [...prev, {
          id: event.tool_call_id,
          type: 'tool',
          toolName: event.tool_name,
          status: 'started',
          timestamp: new Date().toLocaleTimeString()
        }]);
        break;

      case 'TOOL_CALL_ARGS':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.tool_call_id && msg.type === 'tool') {
            return { ...msg, args: event.args };
          }
          return msg;
        }));
        break;

      case 'TOOL_CALL_END':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.tool_call_id && msg.type === 'tool') {
            return { 
              ...msg, 
              status: 'completed',
              result: event.result 
            };
          }
          return msg;
        }));
        break;

      case 'RUN_FINISHED':
        setIsLoading(false);
        break;

      case 'RUN_ERROR':
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'error',
          content: `AG-UI Error: ${event.message}`,
          timestamp: new Date().toLocaleTimeString()
        }]);
        setIsLoading(false);
        break;

      default:
        console.log('Unhandled AG-UI event:', event);
    }
  };

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage = {
      id: Date.now(),
      type: 'user',
      content: input,
      timestamp: new Date().toLocaleTimeString()
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      for await (const event of aguiClient.sendMessage(input, currentThreadId)) {
        handleAGUIEvent(event);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      const errorMessage = {
        id: Date.now() + 1,
        type: 'error',
        content: `Failed to connect to AG-UI middleware: ${error.message}`,
        timestamp: new Date().toLocaleTimeString()
      };
      setMessages(prev => [...prev, errorMessage]);
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  const clearChat = () => {
    setMessages([]);
    setCurrentThreadId(null);
  };

  const getStatusIcon = () => {
    switch (connectionStatus) {
      case 'connected':
        return <Wifi className="status-icon connected" size={16} />;
      case 'connecting':
        return <Clock className="status-icon connecting" size={16} />;
      case 'error':
        return <AlertTriangle className="status-icon error" size={16} />;
      default:
        return <Wifi className="status-icon disconnected" size={16} />;
    }
  };

  const getStatusText = () => {
    switch (connectionStatus) {
      case 'connected':
        return 'Connected to FlightOps AG-UI';
      case 'connecting':
        return 'Connecting...';
      case 'error':
        return 'Connection Error';
      default:
        return 'Disconnected';
    }
  };

  const quickQuestions = [
    "Show me basic info for flight 6E 215",
    "What equipment was used on flight 6E 101?",
    "Get delay summary for flight 6E 215",
    "Show fuel summary for flight 6E 304",
    "Check passenger info for flight 6E 512",
    "Get crew information for flight 6E 215"
  ];

  const handleQuickQuestion = (question) => {
    setInput(question);
  };

  const renderMessage = (message) => {
    if (message.type === 'tool') {
      return (
        <div key={message.id} className="message tool">
          <div className="message-header">
            <div className="message-sender">
              <Tool size={16} />
              <span>Tool: {message.toolName}</span>
            </div>
            <span className="message-time">{message.timestamp}</span>
          </div>
          <div className="message-content">
            Status: {message.status}
            {message.args && (
              <div className="tool-args">
                Arguments: {JSON.stringify(message.args)}
              </div>
            )}
            {message.result && (
              <details>
                <summary>Tool Result</summary>
                <pre>{JSON.stringify(message.result, null, 2)}</pre>
              </details>
            )}
          </div>
        </div>
      );
    }

    // Your existing message rendering for user/assistant/error
    return (
      <div key={message.id} className={`message ${message.type}`}>
        <div className="message-header">
          <div className="message-sender">
            {message.type === 'user' ? <User size={16} /> :
             message.type === 'error' ? <AlertTriangle size={16} /> :
             <Plane size={16} />}
            <span>
              {message.type === 'user' ? 'You' : 
               message.type === 'error' ? 'Error' : 'FlightOps Assistant'}
            </span>
          </div>
          <span className="message-time">{message.timestamp}</span>
        </div>
        <div className="message-content">
          {message.content}
          {message.isStreaming && (
            <span className="typing-indicator">
              <span></span>
              <span></span>
              <span></span>
            </span>
          )}
        </div>
      </div>
    );
  };

  // ... rest of your existing React component (sidebar, header, etc.)
  // Keep all your existing JSX but update the messages rendering to use renderMessage

  return (
    <div className="app">
      {/* Your existing sidebar */}
      <div className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
        <div className="sidebar-header">
          <img src={indigoLogo} alt="Indigo Airlines" className="indigo-logo" />
          <button 
            className="sidebar-toggle"
            onClick={() => setSidebarOpen(!sidebarOpen)}
          >
            {sidebarOpen ? <X size={20} /> : <Menu size={20} />}
          </button>
        </div>
        
        {sidebarOpen && (
          <div className="sidebar-content">
            <div className="welcome-section">
              <h3>Welcome to Indigo FlightOps!</h3>
              <p>Now powered by AG-UI middleware.</p>
            </div>

            <div className="quick-questions">
              <h4>Quick Questions</h4>
              <div className="question-buttons">
                {quickQuestions.map((question, index) => (
                  <button
                    key={index}
                    className="question-btn"
                    onClick={() => handleQuickQuestion(question)}
                    disabled={isLoading}
                  >
                    {question}
                  </button>
                ))}
              </div>
            </div>

            <div className="connection-status">
              <div className="status-indicator">
                {getStatusIcon()}
                <span>{getStatusText()}</span>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Main Content */}
      <div className={`main-content ${!sidebarOpen ? 'expanded' : ''}`}>
        <header className="app-header">
          <div className="header-content">
            <div className="logo">
              <Plane className="logo-icon" size={24} />
              <h1>Indigo FlightOps Assistant</h1>
            </div>
            <div className="status">
              {getStatusIcon()}
              <span className="status-text">{getStatusText()}</span>
            </div>
          </div>
        </header>

        <div className="chat-container">
          <div className="messages-container">
            {messages.length === 0 ? (
              <div className="empty-state">
                <img src={indigoLogo} alt="Indigo Airlines" className="empty-logo" />
                <h2>Welcome to Indigo FlightOps Assistant</h2>
                <p>Now powered by AG-UI middleware. Ask me about flight information, equipment details, delays, fuel data, and more.</p>
              </div>
            ) : (
              messages.map(renderMessage)
            )}
            {isLoading && messages[messages.length - 1]?.type !== 'assistant' && (
              <div className="message assistant">
                <div className="message-header">
                  <div className="message-sender">
                    <Plane size={16} />
                    <span>FlightOps Assistant</span>
                  </div>
                </div>
                <div className="message-content loading">
                  <div className="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                  </div>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>

          <div className="input-container">
            <div className="input-wrapper">
              <textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Ask about Indigo flight information, equipment, delays, fuel data..."
                disabled={isLoading}
                rows={1}
              />
              <button 
                onClick={sendMessage} 
                disabled={!input.trim() || isLoading}
                className="send-button"
              >
                <Send size={18} />
              </button>
            </div>
            {messages.length > 0 && (
              <button onClick={clearChat} className="clear-button">
                Clear Chat
              </button>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

export default App;
##############################################################################################
/* AG-UI Specific Styles */
.message.tool {
    align-self: center;
    background: #f0f9ff;
    border: 1px solid #e0f2fe;
    max-width: 70%;
    margin: 0.5rem auto;
}

.message.tool .message-sender {
    color: #0369a1;
}

.message.tool .tool-args {
    margin: 0.5rem 0;
    padding: 0.5rem;
    background: white;
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.8rem;
}

.message.tool details {
    margin-top: 0.5rem;
}

.message.tool summary {
    cursor: pointer;
    font-weight: 600;
    color: var(--indigo-blue);
}

.message.tool pre {
    background: white;
    padding: 0.5rem;
    border-radius: 4px;
    margin-top: 0.5rem;
    font-size: 0.75rem;
    overflow-x: auto;
    max-height: 200px;
    overflow-y: auto;
}

.typing-indicator {
    display: inline-flex;
    gap: 0.25rem;
    margin-left: 0.5rem;
}

.typing-indicator span {
    height: 6px;
    width: 6px;
    border-radius: 50%;
    background: var(--text-secondary);
    animation: typing 1.4s infinite ease-in-out;
}

.typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator span:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% { transform: scale(0); }
    40% { transform: scale(1); }
}
#########################################################################################
// main.jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'   // Note the .jsx extension
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
############################################################
import React, { useState, useRef, useEffect } from 'react';
import { Send, Plane, Clock, User, Wifi, AlertTriangle, Menu, X, Tool } from 'lucide-react';
import './App.css';

// Import Indigo logo - make sure to place this image in src/assets
import indigoLogo from './assets/indigo-logo.png';

// AG-UI Client for handling event streams
class AGUIClient {
  constructor(baseURL = 'http://localhost:8004') {
    this.baseURL = baseURL;
  }

  async *sendMessage(userInput, threadId = null, runId = null) {
    const response = await fetch(`${this.baseURL}/ag-ui/agent`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: [{ role: 'user', content: userInput }],
        thread_id: threadId,
        run_id: runId,
        tools: []
      }),
    });

    if (!response.ok) {
      throw new Error(`AG-UI error: ${response.status}`);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');
        
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const event = JSON.parse(line.slice(6));
              yield event;
            } catch (e) {
              console.error('Error parsing AG-UI event:', e);
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  async getHealth() {
    const response = await fetch(`${this.baseURL}/ag-ui/health`);
    return response.json();
  }

  async getTools() {
    const response = await fetch(`${this.baseURL}/ag-ui/tools`);
    return response.json();
  }
}

function App() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [currentThreadId, setCurrentThreadId] = useState(null);
  const messagesEndRef = useRef(null);

  const aguiClient = new AGUIClient();

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Check server health on component mount
  useEffect(() => {
    checkHealth();
  }, []);

  const checkHealth = async () => {
    try {
      setConnectionStatus('connecting');
      const health = await aguiClient.getHealth();
      if (health.status === 'healthy') {
        setConnectionStatus('connected');
      } else {
        setConnectionStatus('error');
      }
    } catch (error) {
      setConnectionStatus('error');
      console.error('Health check failed:', error);
    }
  };

  // AG-UI Event Handler
  const handleAGUIEvent = (event) => {
    switch (event.type) {
      case 'RUN_STARTED':
        setCurrentThreadId(event.thread_id);
        console.log('AG-UI Run started:', event.run_id);
        break;

      case 'TEXT_MESSAGE_START':
        setMessages(prev => [...prev, {
          id: event.message_id,
          type: 'assistant',
          content: '',
          timestamp: new Date().toLocaleTimeString(),
          isStreaming: true
        }]);
        break;

      case 'TEXT_MESSAGE_CONTENT':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.message_id) {
            return { ...msg, content: msg.content + (event.delta || '') };
          }
          return msg;
        }));
        break;

      case 'TEXT_MESSAGE_END':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.message_id) {
            return { ...msg, isStreaming: false };
          }
          return msg;
        }));
        break;

      case 'TOOL_CALL_START':
        setMessages(prev => [...prev, {
          id: event.tool_call_id,
          type: 'tool',
          toolName: event.tool_name,
          status: 'started',
          timestamp: new Date().toLocaleTimeString()
        }]);
        break;

      case 'TOOL_CALL_ARGS':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.tool_call_id && msg.type === 'tool') {
            return { ...msg, args: event.args };
          }
          return msg;
        }));
        break;

      case 'TOOL_CALL_END':
        setMessages(prev => prev.map(msg => {
          if (msg.id === event.tool_call_id && msg.type === 'tool') {
            return { 
              ...msg, 
              status: 'completed',
              result: event.result 
            };
          }
          return msg;
        }));
        break;

      case 'RUN_FINISHED':
        setIsLoading(false);
        break;

      case 'RUN_ERROR':
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'error',
          content: `AG-UI Error: ${event.message}`,
          timestamp: new Date().toLocaleTimeString()
        }]);
        setIsLoading(false);
        break;

      default:
        console.log('Unhandled AG-UI event:', event);
    }
  };

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage = {
      id: Date.now(),
      type: 'user',
      content: input,
      timestamp: new Date().toLocaleTimeString()
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      for await (const event of aguiClient.sendMessage(input, currentThreadId)) {
        handleAGUIEvent(event);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      const errorMessage = {
        id: Date.now() + 1,
        type: 'error',
        content: `Failed to connect to AG-UI middleware: ${error.message}`,
        timestamp: new Date().toLocaleTimeString()
      };
      setMessages(prev => [...prev, errorMessage]);
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  const clearChat = () => {
    setMessages([]);
    setCurrentThreadId(null);
  };

  const getStatusIcon = () => {
    switch (connectionStatus) {
      case 'connected':
        return <Wifi className="status-icon connected" size={16} />;
      case 'connecting':
        return <Clock className="status-icon connecting" size={16} />;
      case 'error':
        return <AlertTriangle className="status-icon error" size={16} />;
      default:
        return <Wifi className="status-icon disconnected" size={16} />;
    }
  };

  const getStatusText = () => {
    switch (connectionStatus) {
      case 'connected':
        return 'Connected to FlightOps AG-UI';
      case 'connecting':
        return 'Connecting...';
      case 'error':
        return 'Connection Error';
      default:
        return 'Disconnected';
    }
  };

  const quickQuestions = [
    "Show me basic info for flight 6E 215",
    "What equipment was used on flight 6E 101?",
    "Get delay summary for flight 6E 215",
    "Show fuel summary for flight 6E 304",
    "Check passenger info for flight 6E 512",
    "Get crew information for flight 6E 215"
  ];

  const handleQuickQuestion = (question) => {
    setInput(question);
  };

  const renderMessage = (message) => {
    if (message.type === 'tool') {
      return (
        <div key={message.id} className="message tool">
          <div className="message-header">
            <div className="message-sender">
              <Tool size={16} />
              <span>Tool: {message.toolName}</span>
            </div>
            <span className="message-time">{message.timestamp}</span>
          </div>
          <div className="message-content">
            Status: {message.status}
            {message.args && (
              <div className="tool-args">
                Arguments: {JSON.stringify(message.args)}
              </div>
            )}
            {message.result && (
              <details>
                <summary>Tool Result</summary>
                <pre>{JSON.stringify(message.result, null, 2)}</pre>
              </details>
            )}
          </div>
        </div>
      );
    }

    return (
      <div key={message.id} className={`message ${message.type}`}>
        <div className="message-header">
          <div className="message-sender">
            {message.type === 'user' ? <User size={16} /> :
             message.type === 'error' ? <AlertTriangle size={16} /> :
             <Plane size={16} />}
            <span>
              {message.type === 'user' ? 'You' : 
               message.type === 'error' ? 'Error' : 'FlightOps Assistant'}
            </span>
          </div>
          <span className="message-time">{message.timestamp}</span>
        </div>
        <div className="message-content">
          {message.content}
          {message.isStreaming && (
            <span className="typing-indicator">
              <span></span>
              <span></span>
              <span></span>
            </span>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="app">
      {/* Sidebar */}
      <div className={`sidebar ${sidebarOpen ? 'open' : 'closed'}`}>
        <div className="sidebar-header">
          <img src={indigoLogo} alt="Indigo Airlines" className="indigo-logo" />
          <button 
            className="sidebar-toggle"
            onClick={() => setSidebarOpen(!sidebarOpen)}
          >
            {sidebarOpen ? <X size={20} /> : <Menu size={20} />}
          </button>
        </div>
        
        {sidebarOpen && (
          <div className="sidebar-content">
            <div className="welcome-section">
              <h3>Welcome to Indigo FlightOps!</h3>
              <p>Now powered by AG-UI middleware.</p>
            </div>

            <div className="quick-questions">
              <h4>Quick Questions</h4>
              <div className="question-buttons">
                {quickQuestions.map((question, index) => (
                  <button
                    key={index}
                    className="question-btn"
                    onClick={() => handleQuickQuestion(question)}
                    disabled={isLoading}
                  >
                    {question}
                  </button>
                ))}
              </div>
            </div>

            <div className="flight-info">
              <h4>Flight Data Available</h4>
              <ul>
                <li>‚úì Basic Flight Information</li>
                <li>‚úì Aircraft Equipment Details</li>
                <li>‚úì Operation Times & Delays</li>
                <li>‚úì Fuel Consumption Data</li>
                <li>‚úì Passenger Information</li>
                <li>‚úì Crew Connections</li>
              </ul>
            </div>

            <div className="connection-status">
              <div className="status-indicator">
                {getStatusIcon()}
                <span>{getStatusText()}</span>
              </div>
              <button onClick={checkHealth} className="refresh-status-btn">
                Refresh Status
              </button>
            </div>
          </div>
        )}
      </div>

      {/* Main Content */}
      <div className={`main-content ${!sidebarOpen ? 'expanded' : ''}`}>
        <header className="app-header">
          <div className="header-content">
            <div className="logo">
              <Plane className="logo-icon" size={24} />
              <h1>Indigo FlightOps Assistant</h1>
            </div>
            <div className="status">
              {getStatusIcon()}
              <span className="status-text">{getStatusText()}</span>
            </div>
          </div>
        </header>

        <div className="chat-container">
          <div className="messages-container">
            {messages.length === 0 ? (
              <div className="empty-state">
                <img src={indigoLogo} alt="Indigo Airlines" className="empty-logo" />
                <h2>Welcome to Indigo FlightOps Assistant</h2>
                <p>Now powered by AG-UI middleware. Ask me about flight information, equipment details, delays, fuel data, and more for Indigo Airlines flights.</p>
                <div className="example-queries">
                  <h4>Try asking about:</h4>
                  <div className="example-cards">
                    <div className="example-card">
                      <Plane size={20} />
                      <span>Flight 6E 215 basic info</span>
                    </div>
                    <div className="example-card">
                      <Clock size={20} />
                      <span>Delays for flight 6E 304</span>
                    </div>
                    <div className="example-card">
                      <User size={20} />
                      <span>Passenger count on 6E 512</span>
                    </div>
                    <div className="example-card">
                      <Wifi size={20} />
                      <span>Aircraft equipment details</span>
                    </div>
                  </div>
                </div>
              </div>
            ) : (
              messages.map((message) => renderMessage(message))
            )}
            {isLoading && messages[messages.length - 1]?.type !== 'assistant' && (
              <div className="message assistant">
                <div className="message-header">
                  <div className="message-sender">
                    <Plane size={16} />
                    <span>FlightOps Assistant</span>
                  </div>
                </div>
                <div className="message-content loading">
                  <div className="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                  </div>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>

          <div className="input-container">
            <div className="input-wrapper">
              <textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder="Ask about Indigo flight information, equipment, delays, fuel data..."
                disabled={isLoading}
                rows={1}
              />
              <button 
                onClick={sendMessage} 
                disabled={!input.trim() || isLoading}
                className="send-button"
              >
                <Send size={18} />
              </button>
            </div>
            <div className="input-actions">
              {messages.length > 0 && (
                <button onClick={clearChat} className="clear-button">
                  Clear Chat
                </button>
              )}
              <button onClick={checkHealth} className="health-button">
                Check Connection
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default App;
#################################################################################
/* Additional AG-UI Styles */
.message.tool {
    align-self: center;
    background: #f0f9ff;
    border: 1px solid #e0f2fe;
    max-width: 70%;
    margin: 0.5rem auto;
}

.message.tool .message-sender {
    color: #0369a1;
}

.message.tool .tool-args {
    margin: 0.5rem 0;
    padding: 0.5rem;
    background: white;
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.8rem;
    border: 1px solid #e2e8f0;
}

.message.tool details {
    margin-top: 0.5rem;
}

.message.tool summary {
    cursor: pointer;
    font-weight: 600;
    color: var(--indigo-blue);
    margin-bottom: 0.5rem;
}

.message.tool pre {
    background: white;
    padding: 0.5rem;
    border-radius: 4px;
    margin-top: 0.5rem;
    font-size: 0.75rem;
    overflow-x: auto;
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #e2e8f0;
}

.typing-indicator {
    display: inline-flex;
    gap: 0.25rem;
    margin-left: 0.5rem;
}

.typing-indicator span {
    height: 6px;
    width: 6px;
    border-radius: 50%;
    background: var(--text-secondary);
    animation: typing 1.4s infinite ease-in-out;
}

.typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator span:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% { transform: scale(0); }
    40% { transform: scale(1); }
}

.refresh-status-btn {
    background: var(--indigo-blue);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 0.5rem 1rem;
    cursor: pointer;
    font-size: 0.875rem;
    margin-top: 0.5rem;
    width: 100%;
    transition: background-color 0.2s;
}

.refresh-status-btn:hover {
    background: var(--indigo-light);
}

.health-button {
    background: var(--indigo-blue);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 0.5rem 1rem;
    cursor: pointer;
    font-size: 0.875rem;
    transition: background-color 0.2s;
}

.health-button:hover {
    background: var(--indigo-light);
}

.input-actions {
    display: flex;
    gap: 0.75rem;
    margin-top: 0.75rem;
    justify-content: flex-end;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .message.tool {
        max-width: 90%;
    }
    
    .input-actions {
        flex-direction: column;
    }
    
    .health-button,
    .clear-button {
        width: 100%;
    }
}

/* Scrollbar styling for tool results */
.message.tool pre::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.message.tool pre::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.message.tool pre::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

.message.tool pre::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
################################################################
(venv66) PS C:\Users\Deeksha.x.Srivastava\OneDrive - InterGlobe Aviation Limited\Desktop\agui\backend> python .\start_all_services.py   
üéØ Starting FlightOps Full Stack System
=======================================
üöÄ Starting MCP Server...
üöÄ Starting AG-UI Middleware...
INFO:flightops.mcp.server:Starting FlightOps MCP Server on 127.0.0.1:8000 (transport=streamable-http)
INFO:flightops.mcp.server:MongoDB URL: mongodb+srv://joc-dbuser:n5cqzIJSl319TZN6@mongo-airlineops-az-ddb01-pl-0.npznw.mongodb.net/, Database: jocflightdb_30jan, Collection: flight
INFO:     Started server process [32208]
INFO:     Waiting for application startup.
INFO:mcp.server.streamable_http_manager:StreamableHTTP session manager started
INFO:     Application startup complete.
ERROR:    [Errno 10048] error while attempting to bind on address ('127.0.0.1', 8000): [winerror 10048] only one usage of each socket address (protocol/network address/port) is normally permitted
INFO:     Waiting for application shutdown.
INFO:mcp.server.streamable_http_manager:StreamableHTTP session manager shutting down
INFO:     Application shutdown complete.

‚úÖ All backend services started!
üìä Services Status:
   - MCP Server:        http://localhost:8000
   - AG-UI Middleware:  http://localhost:8004
   - React Frontend:    http://localhost:3000

üîó Your React frontend will connect to the AG-UI Middleware
üéØ You can now start the React frontend with: npm run dev

üåê Open React frontend in browser? (y/n): üåâ Starting FlightOps AG-UI Middleware Bridge...
================================================
üîó This middleware bridges:
   MCP Server (port 8000) ‚Üî AG-UI Protocol
üì° Endpoints:
   - AG-UI Agent: http://localhost:8004/ag-ui/agent
   - Health:      http://localhost:8004/ag-ui/health
   - Tools:       http://localhost:8004/ag-ui/tools
   - Status:      http://localhost:8004/ag-ui/status
üéØ Use this with any AG-UI compatible client!
üîß AG-UI Available: True
INFO:     Started server process [31364]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8004 (Press CTRL+C to quit)
INFO:     127.0.0.1:55366 - "GET /ag-ui/agent HTTP/1.1" 405 Method Not Allowed
INFO:     127.0.0.1:55366 - "GET /favicon.ico HTTP/1.1" 404 Not Found
INFO:FlightOps.MCPClient:üîó Connecting to MCP server at http://127.0.0.1:8000/mcp
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
INFO:mcp.client.streamable_http:Received session ID: bdd0b6c6cd67452c85027d0f475d3df8
INFO:mcp.client.streamable_http:Negotiated protocol version: 2025-06-18
INFO:FlightOps.MCPClient:‚úÖ Connected to MCP server successfully
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 202 Accepted"
INFO:httpx:HTTP Request: GET http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
INFO:FlightOps.MCPClient:üîß Available tools: 9
INFO:httpx:HTTP Request: POST http://127.0.0.1:8000/mcp "HTTP/1.1 200 OK"
INFO:     127.0.0.1:52710 - "GET /ag-ui/tools HTTP/1.1" 200 OK

